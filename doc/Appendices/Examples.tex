\chapter{Examples} \label{app:examples}

\section{The Fibonacci sequence}
Let us have a look at the program in listing \ref{listing:example_fibonacci}. This
program computes the second fibonacci number, and asserts if it is equal to 1. This
program generates the control flow graph shown in figure \ref{fig:cfg_fib}.

\begin{Java}{listing:example_fibonacci}{\text{Program verifying the fib method.}}
class Main {
    public static void main(String[] argv) {
        assert fib(2) == 1 : "fib(2) != 1";
    }

    public static int fib(int x) {
        if (x == 0) {
            return 0;
        } else if (x == 1) {
            return 1;
        } else {
            return fib(x - 1) + fib(x - 2);
        }
    }
}
\end{Java}

When we verify this program using $k=10$, we get the following five program 
paths, of which the shortest is:

\begin{lstlisting}[basicstyle=\small\ttfamily]
[CProver.assume(x==0); { return 0; } assert Main_fib0(2)==1 : "fib(2) != 1";]
\end{lstlisting}

The tool shows that all five program paths are correct. 

Modifying the \javainline{assert fib(2) == 1 : "fib(2) != 1";} to be
\javainline{assert fib(2) == 100 : "fib(2) != 100";} and running the tool again
shows that the assertion does not hold.

\begin{figure}[H]
    \caption{Control flow graph of listing \ref{listing:example_fibonacci}.}
    \label{fig:cfg_fib}
    \centering
    \begin{tikzpicture}[node/.style = {draw, circle}, node distance=1.23cm]
        \node(1)  [label=left:{entry of 'Main.main'}]        {1};
        \node(2)  [below=of 1,label=left:{;}]                           {2};
        \node(3)  [below=of 2,label=left:{call of 'Main.fib'}]          {3};
        \node(7)  [right=of 3,label={entry of 'Main.fib'}]         {7};
        \node(8)  [below=of 7,label=left:{;}]                           {8};
        \node(9)  [below=of 8,label=left:{;}]                           {9};
        \node(10) [below=of 9,label=left:{if (x == 0)}]                 {10};
        \node(11) [below left=of 10,label=left:{return 0;}]                   {11};
        \node(12) [below right=of 10,label=right:{;}]                           {12};
        \node(13) [below=of 12,label=left:{if (x == 1)}]                 {13};
        \node(14) [below left=of 13,xshift=-1cm,label=left:{return 1;}]                   {14};
        \node(15) [below right=of 13,label=left:{call of 'Main.fib'}]          {15};
        \node(16) [below=of 15,label=left:{call of 'Main.fib'}]          {16};
        \node(17) [below=of 16,label={return fib(x-1) + fib(x-2);}] {17};
        \node(18) [below=of 17,label=right:{;}]                           {18};
        \node(19) [below=of 18,label=right:{;}]                           {19};
        \node(20) [below=of 19,label=right:{;}]                           {20};
        \node(21) [below=of 20,label=below:{exit of 'Main.fib'}]          {21};
        \node(4)  [left=of 21,xshift=-0.25cm,label=above:{assert fib(2) == 1}]          {4};
        \node(5)  [left=of 4,xshift=-0.25cm,label=above:{;}]                           {5};
        \node(6)  [left=of 5,xshift=-0.25cm,label=above:{exit of 'Main.main}]          {6};

        \draw[->] (1) -- (2);
        \draw[->] (2) -- (3);
        \draw[->] (3) -- (7);
        \draw[->] (4) -- (5);
        \draw[->] (5) -- (6);
        \draw[->] (7) -- (8);
        \draw[->] (8) -- (9);
        \draw[->] (9) -- (10);
        \draw[->] (10) -- (11);
        \draw[->] (10) -- (12);
        \draw[->] (11.south) to [bend right=90] (19.west);
        \draw[->] (12) -- (13);
        \draw[->] (13) -- (14);
        \draw[->] (13) -- (15);
        \draw[->] (14.south) to [bend right=90] (18.west);
        \draw[->] (15.east) to [bend right] (7.east);
        \draw[->] (16.east) to [bend right] (7.east);
        \draw[->] (17) -- (18);
        \draw[->] (18) -- (19);
        \draw[->] (19) -- (20);
        \draw[->] (20) -- (21);
        \draw[->] (21) -- (4);
        \draw[->] (21.east) to [bend right=90] (16.east);
        \draw[->] (21.east) to [bend right] (17.east);
    \end{tikzpicture}
\end{figure}

\section{Merge sort}
Let us have a look at the program in listing \ref{listing:example_sort}. This 
program defined an array \javainline{elems} which is passed to the \javainline{sort}
method, which is an implementation of merge sort.

The tool correctly verifies the assertion that the array is sorted.

\begin{Java}{listing:example_sort}{Program verifying the sort method.}
class Main {
    public static void main(String[] argv) {
        int[] elems = new int[] { 2, 1 };
        sort(elems, 0, elems.length - 1);
        assert (elems[0] == 1) && (elems[1] == 2);
    }

    public static int partition(int[] array, int low, int high)
    {
        int pivot = array[high];
        int i = low - 1;
        int temp;

        for (int j = low; j < high; j++) {
            if (array[j] <= pivot)
            {
                i++;
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }

        temp = array[i+1];
        array[i+1] = array[high];
        array[high] = temp;

        return i + 1;
    }

    public static void sort(int[] array, int low, int high) {
        if (low < high) {
            int pi = partition(array, low, high);
            sort(array, low, pi - 1);
            sort(array, pi + 1, high);
        }
    }
}
\end{Java}