\section{Lexing and Parsing}
Lexing and parsing is the first phase of the tool. It consists of two subphases:
the lexer and parser, and the syntax transformation. The complete phase takes a 
\haskellinline{String} as input, and transforms it to a \haskellinline{CompilationUnit'}
defined in the \haskellinline{Parsing.Syntax} module. The 
\haskellinline{CompilationUnit'} can be seen as the root node of the abstract
syntax tree.

The lexing and parsing is done using an intermediate abstract syntax tree, defined
in the library \href{http://hackage.haskell.org/package/language-java}{language-java}.
This library also contains the lexer and parser that is used within the tool.

The output of the parser of the 
\href{http://hackage.haskell.org/package/language-java}{language-java} library 
is fed into a syntax transformation subphase. This phase transforms the abstract 
syntax tree of the \href{http://hackage.haskell.org/package/language-java}{language-java} 
library into the abstract syntax tree defined in \haskellinline{Parsing.Syntax}.
Our abstract syntax tree is almost an one-to-one correspondence of the abstract
syntax tree defined in \href{http://hackage.haskell.org/package/language-java}{language-java}.

The definitions in \haskellinline{Parsing.Syntax} are contained in an attribute 
grammar file, which can be built using the Attribute Grammar System of Utrecht
University\footnote{\url{hackage.haskell.org/package/uuagc}}. This system allows
easy information retrieval of the abstract syntax tree, but at the cost that we
cannot use the abstract syntax tree defined in the 
\href{http://hackage.haskell.org/package/language-java}{language-java} library 
directly.

\subsection{The supported subset of Java}
Only a subset of the Java language is supported. There is support for a single
Java source file containing one or more class declarations. Interfaces and enum 
declarations are not supported. 

Classes may contain fields, methods and constructors. All modifiers on these 
levels are supported, including annotations. Classes may not contain generics, 
note that JBMC also does not have support for generics. Methods and constructors
may not be overloaded, there cannot exist two methods with the same name in the
same class.

Methods and constructors contain statements, of which we distinct two types. 
Compound statements, and basic statements. Compound statements are statements 
which itself contain statements. Basic statements are statements which do 
not contain statements. A constructor may not call its base constructor explicitly.
The compound statements that are supported are:

\begin{itemize}
    \item A block, introduced using curly braces;
    \item an \javainline{if else} statement;
    \item a \javainline{while} loop;
    \item a \javainline{try catch finally} statement;
    \item a \javainline{for} loop.
\end{itemize}

Note that \javainline{while}- and \javainline{for} loops can be labeled, e.g.
\javainline{l: while(g)}.

The basic statements that are are supported are:

\begin{multicols}{2}
    \begin{itemize}
        \item A variable declaration;
        \item a skip statement;
        \item an expression statement;
        \item an \javainline{assert} statement;
        \item a \javainline{break} statement;
        \item a \javainline{continue} statement;
        \item a \javainline{return} statement;
        \item a \javainline{throw} statement.
\end{itemize}
\end{multicols}

An assume statement can be written as \javainline{CProver.assume(e)}. The package
that contains the \javainline{CProver} class does not have to be included as this 
is done by the compiler.

There is one contextual issue: having a \javainline{break} or 
\javainline{continue} statement transferring the control flow from a 
\javainline{try}, \javainline{catch} or \javainline{finally} statement. For 
example, see listing \ref{listing:java_break_problem}. This code is semantically 
valid, but fails to compile correctly. 

\begin{Java}{listing:java_break_problem}{\text{Breaking from a catch, which is problematic.}}
void foo() {
    int x = 0;
    while (true) {
        try {
            x = x / x;
        } catch (ArithmeticException e) {
            break;
        }
    }
}
\end{Java}

All expression constructs are supported, except for three. There is no support for 
casting, the \javainline{instanceof} operator, and lambda expressions. Lambda 
expressions are unsupported by JBMC.
