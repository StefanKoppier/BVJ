\section{Linearization}
The third phase is the linearization phase; the phase that takes a control flow 
graph and generates all program paths from the starting point of the method to
be verified until the last point of method to be verified, up to the length $k$.

The verification starts at the method entry point node of the method to be verified
and ends at the method exit point of the method to verified if there are no more 
stack frames on the call stack. This is due to recursive method calls.

The length of a program paths is defined by the number of basic statements in the
program path, not counting any empty statement, i.e. \javainline{;}. This choice
is made as most realistic programs do not contain empty statements, but the tool
inserts skip statements at multiple places, keeping $k$ similar to the original 
program.

A program path is defined as a list of \haskellinline{PathStmt}, a 2-tuple 
containing a \haskellinline{PathType} and a \haskellinline{PathMetaInfo}. The 
\haskellinline{PathType} can be either a basic statement, an block entry or an 
block exit. The \haskellinline{PathMetaInfo} contains information about the package,
class and method, and the call name of the method this \haskellinline{PathType} is
enclosed in.

\subsection{The construction of the program paths}
The program path construction algorithm works as follows. We traverse edges of
the control flow graph from the method entry node of the method to be verified
until we either reach the final node, or the generated program path exceeds the
maximum length $k$.

During the traversal, we keep track of an accumulator \haskellinline{PathAccumulator} 
which is a 5-tuple containing:

\begin{itemize}
    \item The \haskellinline{CallHistory}: the number of times each method is called;
    \item the \haskellinline{StmtManipulations}: the method renaming that has to be
    performed at each node;
    \item the \haskellinline{CallStack}: the stack of method calls;
    \item the \haskellinline{ProgramPaths}: the program paths generated thus far;
    \item and the \haskellinline{Int}: the length we can append to the current
    paths, i.e. $k-$current length of the program paths generated thus far. 
\end{itemize}

When we reach a node that contains a statement, we append it to all program paths
and check if this node contains an method calls. If this is the case, we traverse
the expression in the statement and rename the method calls, this is done in the
\haskellinline{Linearization.Renaming} module.

When we traverse an edge, we check if the edge contains a block entry or exit. If 
this is the case, we add this block entry or exit to all paths and continue the
traversal. The complete algorithm can be found in the 
\haskellinline{Linearization.Path} module.