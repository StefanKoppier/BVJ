\section{Analysis}
The second phase of the tool is the Control Flow Analysis. It takes a 
\haskellinline{CompilationUnit'} as input and transforms it into a 
\haskellinline{CFG}, defined in the \haskellinline{Analysis.CFG} module.

The control flow graph is implemented using the inductive graph representation
of the \href{http://hackage.haskell.org/package/fgl}{fgl} library. The inductive
graph is a graph suitable for functional style programming. They are developed
by Martin Erwig \cite{erwig2001inductive}.

\begin{definition}
The Control Flow Graph (CFG) of a Java program $P$ is a directed graph $G_P=(V,E)$
where

\begin{itemize}
    \item $V$ is the set of nodes. Each node is one of either:
    \begin{enumerate*}
        \item a method entry point;
        \item a method exit point;
        \item an invocation of an method;
        \item a statement, for initializer, or a for update;
        \item a catch block;
        \item a finally block.
    \end{enumerate*}
    \item $E$ is the set of edges. Each edge is one of either:
    \begin{enumerate*}
        \item an intraprocedural edge;
        \item an interprocedural edge;
        \item an intraprocedural block entry edge;
        \item an intraprodudural block exit edge;
        \item an intraprocedural block entry and exit edge.
    \end{enumerate*}
\end{itemize}
\end{definition}

A block is a point where the control flow enters a new scope. We define five 
types of blocks:

\begin{labeling}{\textbf{The try, catch and finally blocks}}
    \item[\textbf{A basic block}] induced by a pair of brackets not following a method,
    conditional block, or try catch finally blocks.
    \item[\textbf{A conditional block}] induced by a conditional block, i.e. an if then 
    else statement or a loop structure.
    \item[\textbf{The try, catch and finally blocks}] induced by a try catch finally statement.
\end{labeling}

\subsection{The construction of the control flow graph}
The construction of the control flow graph is based on the control flow analysis
described in Principles of Program Analysis by Nielson et al. 
\cite{nielson2015principles}. It labels each statement in the program with an unique
number, and each statement has an initial label and final labels. We will describe 
the initial, the final labels, and the set of vertices and set of edges for each 
kind of compound statement below. 

We denote the initial node of a statement by $init : Statement \rightarrow Node$, the 
final nodes of a statement by $final : Statement \rightarrow \{Node\}$. 
We use $V(x)$ and $E(x)$ to denote the set of vertices and edges generated by object
$x$. We use $node(x)$, $edge(x)$, and $edges(x, y)$ to denote a new node, or new 
edge(s) for objects $x$ and $y$.

\subsubsection*{A constructor or method}
Given a constructor or method $M$ with body $S$, we will have:
\begin{align*}
    V &=\{node(M_{entry}), node(M_{exit})\} \cup V(S) \\ \\
    E &=
    \begin{cases}
      edge(node(M_{entry}), node(M_{exit})) 
        & \text{if } V(S) = \emptyset \\
      edge(node(M_{entry}), init(S)) \cup edges(final(S), node(M_{exit})) \cup E(S)
        & \text{otherwise}
    \end{cases}
\end{align*}

Or less formally, the vertices are the method entry point the method exit point, 
and the vertices created by the body of the method. The edges are an edge from
the method entry point to the initial of the body, and the edges from the final
of the body to the method exit point.

\subsubsection*{A sequence of statements}
Given a sequence $S$ of statements $S_1$ and $S_2$. We have that:
\begin{align*}
    init(S)  &= init(S_1) \\ \\
    final(S) &= final(S_2) \\ \\
    V &= V(S_1) \cup V(S_2) \\ \\
    E &= 
    \begin{cases}
        E(S_1) 
            & \\ \quad \text{if } S_1 \text{ is a \javainline{break} or \javainline{continue}} \\ \\
        edges(final(S_1), init(S_2)) \cup edges(breaks(S_1), init(S_2)) \cup E(S_1) \cup E(S_2) 
            & \\ \quad \text{if } S_1 \text{ is a loop} \\ \\
        edges(final(S_1), init(S_2))  \cup E(S_1) \cup E(S_2) 
            & \\ \quad \text{otherwise}
    \end{cases}
\end{align*}

Or less formally, the vertices are the vertices of the statements. The edges are
the edges of the statements, and we have three cases:
\begin{itemize}
    \item We have a \javainline{break} or \javainline{continue} statement: we
    end the sequence at the first statement;
    \item we have a loop statement: we add an edge from the final of the first 
    statement and the break statements of the loop to the initial of second 
    statement;
    \item we have any other statement: we add an edge from the final of the first
    statement to the initial of the next statement.
\end{itemize}

\subsubsection*{An if else statement}
Given an if else statement $I$, with the body of the true branch $S_\top$ and the
body of the false branch $S_\bot$, we will have:
\begin{align*}
    init(I)  &= node(I) \\ \\
    final(I) &= final(S_\top) \cup final(S_\bot) \\ \\
    V        &= \{node(I)\} \cup V(S_\top) \cup V(S_\bot) \\ \\
    E        &= edge(node(I), init(S_\top)) \cup edge(node(I), init(S_\bot)) 
                \cup E(S_\top) \cup E(S_\bot)
\end{align*}

Or less formally, the vertices are the if else statement itself, and the nodes
of the true branch and the false branch. The edges are, an edge from the 
if else statement itself to the initial of the body of the true branch and to
the initial of the body of the false branch.

\subsubsection*{A while loop}
Given a while loop $L$, with guard $g$ and body $S$, we have:
\begin{align*}
    init(L) &=
    \begin{cases}
      node(L) & \text{if } V(g) = \emptyset \\
      init(g) & otherwise
    \end{cases} \\ \\
    final(L) &= \{node(L)\} \\ \\
    V &= \{node(L)\} \cup V(S) \cup V(g) \\ \\
    E &= edge(node(L), init(S)) \cup edges(final(S), init(L))
       \\ & \quad \cup edges(continues(L), init(L)) \cup E(S) \cup E(g)
\end{align*}

where $continues(L)$ denotes the \javainline{continue} statements that belong
to the loop $L$.

Or less formally, the vertices are the loop itself, and the nodes of the loop 
body. The edges are, an edge from the loop itself to the initial body, edges from
the final of the body to the loop itself, edges from the continue statements of
this loop to the loop itself and the edges generated by the body of this loop.

Note that a while loop is always followed by a \javainline{CProver.assume(!g)}
statement.

\subsubsection*{A try catch finally statement}
Given a try statement $T$ with body $S_T$ catch statements $[C_1, \ldots, C_n]$
with bodies $[S_1, \ldots, S_n]$ and possibly a finally statement $F$ with body
$S_F$, we will have:
\begin{align*}
    init(T)  &= node(T) \\ \\
    final(T) &= 
    \begin{cases}
        final(S_F) & \text{if } T \text{ has a \javainline{finally} block}  \\
        final(S_n) & \text{otherwise}
    \end{cases} \\ \\
    V &= \{node(T), node(C_i), \ldots, node(C_n) \} \cup \{node(F)\} \cup V(S_T) \cup V(S_1) \cup \ldots \cup V(S_n) \cup S_F \\ \\
    E &= edge(node(T), init(S_T)) \cup edges(final(S_T), node(C_1)) \cup edge(node(C_1), init(S_1)) 
        \\ & \quad \cup edges(final(S_1), node(C_2)) \cup \ldots \cup edges(final(C_n), node(F))
        \\ & \quad  \cup edge(node(F), init(S_F)) \cup E(S_T) \cup E(S_1) \cup \ldots \cup E(S_n) \cup E(S_F) 
\end{align*}

Or less formally, the vertices are the try statement, catch statements and finally
statement with all bodies of these blocks combined. The edges are an edge from
the try statement to the init of the try statement itself, and we chain all
finals of the following blocks to the nodes of the try statements that follow.

\subsubsection*{A for loop}
Given a for loop $L$ with body $S$ and initialization expression $i$, guard $g$,
and update expression $u$.
\begin{align*}
    init(L) &= 
    \begin{cases}
        node(i) & \text{if }i \text{ exists} \\
        node(L) & \text{otherwise}
    \end{cases} \\ \\
    final(L) &= \{node(L)\} \\ \\
    V        &= \{node(i), node(L), node(u)\} \cup V(S) \\ \\ 
    E        &= edge(node(i), node(L)) \cup edge(node(L), init(S)) \cup edges(final(S), node(u))
                \\ & \quad \cup edges(node(u), node(L)) \cup edges(continues(L), node(u)) \cup E(S)
\end{align*}

Or less formally, we have a node for the loop itself, the initialization, the 
update and the body of the loop. We have an edge from the update to the loop
itself, an edge from the loop itself to the initial of the body. We have an edge from
the final of the body to the update, or the loop itself, depending if the update
exists. Finally, we have an edge from the update to the loop itself, if the update
exists.

Note that a for loop is always followed by a \javainline{CProver.assume(!g)}
statement.

\subsection{Reachability analysis}
The tool has a subphase in place which allows for reachability analysis. This
reachability analysis is a depth-first search starting at node $v \in V$ which
corresponds to the method entry point of the method to be verified. This subphase
is currently disabled as it may construct correct, but hard to read graphs, when
verifying a specific method that is not \javainline{main}.
