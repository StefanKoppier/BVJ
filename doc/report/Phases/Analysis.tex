\section{Analysis}

\subsection{Syntax Transformation}

\subsection{Control Flow Analysis}

\begin{definition}
\todo{Define a basic block.}
\end{definition}

\begin{definition}
The Control Flow Graph (CFG) of a method $M$ is a directed graph $G_M=(V,E,s)$
where
\begin{itemize}
    \item $V$ is the set of nodes. Each vertex $v$ in $V$ is a pair consisting
    of an integral label, and a basic block. There exists a vertex $v$ for every 
    basic block in the method $M$.
    \item $E$ is the set of edges. There exists an edge $(u,v)$ if and only if 
    the basic block of $v$ follows the basic block of $v$ in the method $M$.
    \item $s$ is the vertex in $V$ that is the initial basic block in the method 
    $M$.
\end{itemize}
\end{definition}

\begin{definition}
The Extended Control Flow Graph (ECFG) of a program $P$ is a directed graph 
$G_P=(V,E,s)$ where
\begin{itemize}
    \item $V$ is the set of nodes. Each vertex $v$ in $V$ is a pair consisting
    of an integral label, and a CFG. There exists a vertex $v$ for every method 
    $M$ in $P$.
    \item $E$ is the set of edges. There exists an edge $(u,v)$ if and only if 
    the method of $u$ invokes the method of $v$.
    \item $s$ is the initial method of the program $P$.
\end{itemize}
\end{definition}

We perform the Control Flow Analysis (CFA) in a way similar to that described by
Nielson et al. \cite{nielson2015principles}.

We define the CFA as:

\begin{align*}
    init([x = e]^l)                                             &= l          \\
    init([S_1];\;[S_2])                                         &= init(S_1)  \\
    init([\textbf{assert}\;e\;g]^l)                             &= l          \\
    init([\textbf{assume}\;e\;g]^l)                             &= l          \\
    init([\textbf{break}\;x]^l)                                 &= l          \\
    init([\textbf{continue}\;x]^l)                              &= l          \\
    init(\textbf{if}\;([e]^l)\;\{S\})                           &= l          \\
    init(\textbf{if}\;([e]^l)\;\{S_1\}\;\textbf{else}\;\{S_2\}) &= l          \\
    init(\textbf{while}\;([e]^l)\;\{S\})                        &= l          \\
    init(\textbf{for}\;(;\;[e]^l;\;\dots)\;\{S\})               &= l          \\
    init(\textbf{for}\;([i]^{l'};\;[e]^l;\;\dots)\;\{S\})       &= l'
\end{align*}

\begin{align*}
    final([x = e]^l)                                             &= \{l\}                      \\
    final([S_1];\;[S_2])                                         &= final(S_2)                 \\
    final([\textbf{assert}\;e\;g]^l)                             &= \{l\}                      \\
    final([\textbf{assume}\;e\;g]^l)                             &= \{l\}                      \\
    final([\textbf{break}\;x]^l)                                 &= \{l\}                      \\
    final([\textbf{continue}\;x]^l)                              &= \{l\}                      \\
    final(\textbf{if}\;([e]^l)\;\{S\})                           &= final(S)                   \\
    final(\textbf{if}\;([e]^l)\;\{S_1\}\;\textbf{else}\;\{S_2\}) &= final(S_1) \cup final(S_2) \\
    final(\textbf{while}\;([e]^l)\;\{S\})                        &= \{l\} \cup breaks_0(S)     \\
    final(\textbf{for}\;(\dots;\;[e]^l;\;\dots)\;\{S\})          &= \{l\} \cup breaks_0(S)     \\
    final(x:\;\textbf{while}\;([e]^l)\;\{S\})                    &= \{l\} \cup breaks_x(S)     \\
    final(x:\;\textbf{for}\;(\dots;\;[e]^l;\;\dots)\;\{S\})      &= \{l\} \cup breaks_x(S) 
\end{align*}

\begin{align*}
    flow([x = e]^l)                                             &= \emptyset  \\
    flow([S];\;[\textbf{break}\;x]^l)                           &= flow(S)    \\
    flow([S];\;[\textbf{continue}\;x]^l)                        &= flow(S)    \\
    flow([S_1];\;[S_2])                                         &= flow(S_1) \cup flow(S_2) \cup \{(l,init(S_2)\;| \in final(S_1))\}  \\
    flow([\textbf{assert}\;e\;g]^l)                             &= \emptyset          \\
    flow([\textbf{assume}\;e\;g]^l)                             &= \emptyset          \\
    flow([\textbf{break}\;x]^l)                                 &= \emptyset          \\
    flow([\textbf{continue}\;x]^l)                              &= \emptyset          \\
    flow(\textbf{if}\;([e]^l)\;\{S\})                           &= flow(S) \cup (l,init(S))  \\
    flow(\textbf{if}\;([e]^l)\;\{S_1\}\;\textbf{else}\;\{S_2\}) &= flow(S_1) \cup flow(S_2) \cup (l,init(S_1)) \cup (l,init(S_2)) \\
    flow(\textbf{while}\;([e]^l)\;\{S\})                        &= todo           \\
    flow(\textbf{for}\;(;\;[e]^l;\;\dots)\;\{S\})               &= todo           \\
    flow(\textbf{for}\;([i]^{l'};\;[e]^l;\;\dots)\;\{S\})       &= todo 
\end{align*}

\subsection{Reachability Analysis}