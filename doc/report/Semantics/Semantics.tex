\chapter{On the semantical differences between Java and C}

\section{Types}
The supported Java subset consists of three kind of types: primitives, 
(multi-dimensional) arrays, and classes.

In Java, primitives are stack-allocated, and arrays and classes are heap-allocated.
This requires primitives to be treated as plain types, and arrays and objects to
be treated as pointers.

\subsection{Primitive data types}
Java defines eight primitive data types: \javainline{boolean}, 
\javainline{char}, \javainline{byte}, \javainline{short}, \javainline{int},
\javainline{long}, \javainline{float}, and \javainline{double}. All integral 
values are signed.

C defines one boolean type: \cinline{\_Bool}, five standard signed integer types: 
\cinline{signed char}, \cinline{short int}, \cinline{int}, \cinline{long int},
\cinline{long long int}, and three standard floating point types: \cinline{float},
\cinline{double}, and \cinline{long double} \cite[p.~40]{iso_c_standard}. The 
downside of the integral primitives is that their size is not exactly specified, 
and is thus implementation specific. For example, the \cinline{int} primtive can
be 32- or 64-bit, depending on the implementation. Luckily, CBMC defines four
exact sized integral values: \cinline{\_\_int8}, \cinline{\_\_int16}, 
\cinline{\_\_int32}, and \cinline{\_\_int64} \cite[p.~39]{cprover_manual}.

We can define an exact mapping of the primitve data types of Java, to those of
C and CBMC. This mapping can be found in \ref{table:primitve_data_type_conversions}.

\begin{table}[H]
    \centering
    \caption{Mapping of the primitive data types.}
    \label{table:primitve_data_type_conversions}
    \begin{tabular}{lll}
    \hline
    \textbf{Type}        & \textbf{Description}                 & \textbf{C equivalent} \\ \hline
    \javainline{boolean} & true or false                        & \cinline{\_Bool}      \\
    \javainline{char}    & 16-bit Unicode value                 &                       \\
    \javainline{byte}    & 8-bit signed integral value          & \cinline{\_\_int8}    \\
    \javainline{short}   & 16-bit signed integral value         & \cinline{\_\_int16}   \\
    \javainline{int}     & 32-bit signed integral value         & \cinline{\_\_int32}   \\
    \javainline{long}    & 64-bit signed integral value         & \cinline{\_\_int64}   \\
    \javainline{float}   & IEEE 754 32-bit floating point value & \cinline{float}       \\
    \javainline{double}  & IEEE 754 64-bit floating point value & \cinline{double}      \\ \hline
    \end{tabular}
\end{table}

\subsection{Arrays}
Both Java and C have a concept of an array, but they are vastly different. In 
Java an array is an heap-allocated structure, in C an array is a stack-allocated 
structure, unless it explicitly allocated on the heap. The length of an array is
contained in the Java array structure, this needs to be maintained explicitly in 
C.

To ease both differences, the choice is made to map the Java type of an array 
to a C struct, containing the elements in the array and the length of the array.

For example, the type \javainline{int[]} will be mapped to:
\begin{C}
struct Int_Array {
    __int32 *elements;
    __int32 length;
};
\end{C}

Multi-dimensional arrays are mapped in the same way. For example, the type 
\javainline{int[][]} will be mapped to:

\begin{C}
struct Int_Array {
    __int32 *elements;
    __int32 length;
};

struct Int_Array_Array {
    struct Int_Array **elements;
    __int32 length;
};
\end{C}

\subsection{Classes}
There is no direct translation of a Java class to a C class, as C does not have 
the concept of a class. A Java class consists of three components:

\begin{labeling}{Constructors}
    \item [Fields] Fields can be divided in two sets, non-static fields, which 
    are part of an instantiation of the class, and static fields, which are not
    part of an instantiation.
    \item [Methods] Methods can also be divided in two sets, non-static methods,
    which have an hidden \javainline{this} parameter to the object the method is
    called on, and static methods, which are not called on a specific object. 
    \item [Constructors] The constructors are always static, and return an object
    of the type the constructor is defined in.
\end{labeling}

The class will be mapped to a struct declaration, containing all non-static
fields of that class. All static fields will be mapped to a global variable 
declaration. In the mapping to C, methods and constructors are no longer part of 
the type itself, but a method will be declared for each invocation. The mapping 
of methods and constructors is be described in \todo{reference the mapping of methods.}.

For example, given the following class \javainline{Foo}, without its method and 
constructor declarations:

\begin{Java}
class Foo {
    static bool b;
    int x;
}
\end{Java}

will be mapped to the following declarations in C

\begin{C}
_Bool Foo_b;

struct Foo {
    __int32 x;
};
\end{C}

\section{Expressions}

\subsection{Literals}

\subsection{Operators}

\subsection{Assignment}

\subsection{Method invocation}

\subsection{Array creation}


\section{Statements}