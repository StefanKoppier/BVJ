--------------------------------------------------------------------------------
-- Expresion control flow generation
--
-- This file is responsible for creating the control flow of expressions.
-- The only control flow generated by an expression is that of a method call.
--------------------------------------------------------------------------------

attr MaybeExp' Exps' Exp' FieldAccess' VarDecls' VarDecl' VarInits' VarInit' 
     MaybeVarInits' MethodInvocation' ArrayIndex' Lhs' 
    chn label                       :: {Node}
    syn init                        :: {CFGNode}
    syn final                       :: {CFGDepthNodes}
    syn nodes         use {++} {[]} :: {CFGNodes}
    syn edges         use {++} {[]} :: {CFGEdges}
    syn numberOfCalls use {+} {0}   :: {Int}

sem MethodInvocation'
    | MethodCall'        lhs.numberOfCalls = 1 + @args.numberOfCalls
    | PrimaryMethodCall' lhs.numberOfCalls = 1 + @exp.numberOfCalls + @args.numberOfCalls

sem Exp'
    | InstanceCreation' lhs.numberOfCalls = 1 + @args.numberOfCalls

attr MaybeExp' Exps' Exp' VarDecls' VarDecl' VarInits' VarInit' MethodInvocation'
     MaybeVarInits' ArrayIndex' Lhs'
    inh statNode :: {Node}

sem Exps'
    | Cons      lhs.init  = if noNode == @hd.init
                                then @tl.init
                                else @hd.init
                   .final = if null @tl.final
                                then @hd.final
                                else @tl.final
    | Nil       lhs.init  = noNode
                   .final = [] 

sem MaybeExp'
    | Nothing           lhs .init  = noNode
                            .final = []

sem Exp'
    | Lit'              lhs .label  = @lhs.label
                            .init   = noNode
                            .final  = []
                        
    | This'             lhs .init   = noNode
                            .final  = []

    | InstanceCreation' lhs .label = new @args.label
                            .init  = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        if noNode == @args.init
                                            then call (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self)
                                            else @args.init 
                            .final = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        [(call (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self), 0)]
                            .nodes = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        call (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self) : @args.nodes
                            .edges = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        -- Inter edge from the call to the entry
                                        callEdge (new @args.label, scope) @lhs.methods
                                        : -- Inter edge from the exit to the next node
                                        returnEdge (scope, new (new @args.label))  @lhs.methods
                                        ++ @args.edges
                        args.label = @lhs.label

    | ExpName'          lhs .label  = @lhs.label
                            .init   = noNode
                            .final  = []

    | BinOp'            lhs .label   = @exp2.label
                            .init    = if noNode == @exp1.init
                                        then @exp2.init
                                        else @exp1.init
                            .final  = if null @exp2.final
                                        then @exp1.final
                                        else @exp2.final
                            .edges  = @exp1.edges ++ @exp2.edges
                        exp1.label = @lhs.label
                        exp2.label = @exp1.label

    | Cond'             lhs .label = @exp2.label
                            .init  = if noNode == @guard.init
                                        then if noNode == @exp1.init
                                                then @exp2.init
                                                else @exp1.init
                                        else @guard.init
                            .final = if null @exp2.final
                                        then if null @exp1.final
                                                then @guard.final
                                                else @exp2.final
                                        else @exp1.final
                        guard.label = @lhs.label
                        exp1 .label = @guard.label
                        exp2 .label = @exp1.label

sem MethodInvocation'
    | MethodCall' lhs.label  = new @args.label
                     .init   = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    if noNode == @args.init
                                        then call (new @args.label) scope @lhs.statNode @name.self
                                        else @args.init
                     .final  = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    [(call (new @args.label) scope @lhs.statNode @name.self, 0)]
                     .nodes  = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    call (new @args.label) scope @lhs.statNode @name.self : @args.nodes
                     .edges  = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    -- Inter edge from the call to the entry
                                    callEdge (new @args.label, scope) @lhs.methods
                                    : -- Inter edge from the exit to the next node
                                    returnEdge (scope, new (new @args.label))  @lhs.methods
                                    -- The edges of the call arguments.
                                    ++ @args.edges
                  args.label = @lhs.label

    | PrimaryMethodCall' lhs .label = new @args.label
                             .init  = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            if noNode == @exp.init
                                                then if noNode == @args.init
                                                        then call (new @args.label) scope @lhs.statNode [@name]
                                                        else @args.init
                                                else @exp.init
                             .final = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            [(call (new @args.label) scope @lhs.statNode [@name], 0)]
                             .nodes = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            call (new @args.label) scope @lhs.statNode [@name]
                                            : @exp.nodes ++ @args.nodes
                             .edges =  let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                           scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            -- Inter edge from the call to the entry
                                            callEdge (new @args.label, scope) @lhs.methods
                                            : -- Inter edge from the exit to the next node
                                            returnEdge (scope, new (new @args.label)) @lhs.methods
                                            -- The edges of the exp and call arguments.
                                            ++ @exp.edges ++ @args.edges
                         exp .label = @lhs.label
                         args.label = @exp.label 

sem Lhs'
    | Name' lhs .init  = noNode
                .final = []