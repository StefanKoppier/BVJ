--------------------------------------------------------------------------------
-- Expresion control flow generation
--
-- This file is responsible for creating the control flow of expressions.
-- The only control flow generated by an expression is that of a method call.
--------------------------------------------------------------------------------

attr    MaybeExps' Exps' MaybeExp' Exp' FieldAccess' VarDecls' VarDecl' VarInits' 
        VarInit' MaybeVarInits' MethodInvocation' ArrayIndex' Lhs' 
    chn label                       :: {Node}
    syn init                        :: {CFGNode}
    syn final                       :: {CFGNodes}
    syn nodes         use {++} {[]} :: {CFGNodes}
    syn edges         use {++} {[]} :: {CFGEdges}
    syn numberOfCalls use {+} {0}   :: {Int}

sem MethodInvocation'
    | MethodCall'        lhs.numberOfCalls = 1 + @args.numberOfCalls
    | PrimaryMethodCall' lhs.numberOfCalls = 1 + @exp.numberOfCalls + @args.numberOfCalls

sem Exp'
    | InstanceCreation' lhs.numberOfCalls = 1 + @args.numberOfCalls

attr    MaybeExps' MaybeExp' Exps' Exp' VarDecls' VarDecl' VarInits' VarInit' 
        MethodInvocation' MaybeVarInits' ArrayIndex' Lhs'
    inh statNode :: {Node}

sem MaybeExps'
    | Just      lhs .label  = @just.label
                    .init   = @just.init
                    .final  = @just.final
    | Nothing   lhs .init   = noneNode
                    .final  = []

sem Exps'
    | Cons      lhs .label  = @tl.label
                    .init   = ifNoneNode @hd.init @tl.init
                    .final  = if null @tl.final then @hd.final else @tl.final
    | Nil       lhs .label  = @lhs.label
                    .init   = noneNode
                    .final  = [] 

sem MaybeExp'
    | Nothing           lhs .init  = noneNode
                            .final = []

sem Exp'
    | Lit'              lhs .label  = @lhs.label
                            .init   = noneNode
                            .final  = []
                        
    | This'             lhs .init   = noneNode
                            .final  = []

    | InstanceCreation' lhs .label = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self 
                                        in maybe @args.label (const (new @args.label)) scope
                            .init  = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self
                                         self  = callNode (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self) 
                                        in if noneNode == @args.init
                                                then maybe noneNode id self
                                                else @args.init 
                            .final = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self
                                         self  = callNode (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self)  
                                        in addMaybeNode self []
                            .nodes = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self
                                         self  = callNode (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self) 
                                        in addMaybeNode self @args.nodes
                            .edges =  let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self 
                                        in -- Inter edge from the call to the entry.
                                           (addMaybeEdge (callEdge (new @args.label, scope) @lhs.methods)
                                           . -- Inter edge from the exit to the next node.
                                           addMaybeEdge (returnEdge (scope, new (new @args.label)) @lhs.methods))
                                           @args.edges
                        args.label = @lhs.label

    | ExpName'          lhs .label  = @lhs.label
                            .init   = noneNode
                            .final  = []

    | BinOp'            lhs .label  = @exp2.label
                            .init   = ifNoneNode @exp1.init @exp2.init
                            .final  = if null @exp2.final
                                        then @exp1.final
                                        else @exp2.final
                            .edges  = @exp1.edges ++ @exp2.edges
                        exp1.label  = @lhs.label
                        exp2.label  = @exp1.label

    | Cond'             lhs .label = @exp2.label
                            .init  = if noneNode == @guard.init
                                        then ifNoneNode @exp1.init @exp2.init
                                        else @guard.init
                            .final = if null @exp2.final
                                        then if null @exp1.final
                                                then @guard.final
                                                else @exp2.final
                                        else @exp1.final
                        guard.label = @lhs.label
                        exp1 .label = @guard.label
                        exp2 .label = @exp1.label

sem MethodInvocation'
    | MethodCall' lhs   .label  = let scope = getScopeOfInvocation @lhs.ast Nothing (Just @lhs.className) @lhs.types @name.self 
                                    in maybe @args.label (const (new @args.label)) scope
                        .init   = let scope = getScopeOfInvocation @lhs.ast Nothing (Just @lhs.className) @lhs.types @name.self
                                      self  = callNode (new @args.label) scope @lhs.statNode @name.self 
                                    in if noneNode == @args.init
                                            then maybe noneNode id self
                                            else @args.init
                        .final  = let scope = getScopeOfInvocation @lhs.ast Nothing (Just @lhs.className) @lhs.types @name.self
                                      self  = callNode (new @args.label) scope @lhs.statNode @name.self
                                    in addMaybeNode self []
                        .nodes  = let scope = getScopeOfInvocation @lhs.ast Nothing (Just @lhs.className) @lhs.types @name.self
                                      self  = callNode (new @args.label) scope @lhs.statNode @name.self
                                    in addMaybeNode self (@args.nodes)
                        .edges  = let scope = getScopeOfInvocation @lhs.ast Nothing (Just @lhs.className) @lhs.types @name.self 
                                    in -- Inter edge from the call to the entry.
                                       (addMaybeEdge (callEdge (new @args.label, scope) @lhs.methods)
                                       . -- Inter edge from the exit to the next node.
                                       addMaybeEdge (returnEdge (scope, new (new @args.label)) @lhs.methods))
                                       @args.edges
                  args  .label  = @lhs.label

    | PrimaryMethodCall' lhs .label = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] 
                                        in maybe @args.label (const (new @args.label)) scope
                             .init  = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name]
                                          self      = callNode (new @args.label) scope @lhs.statNode [@name]
                                        in if noneNode == @exp.init
                                                then if noneNode == @args.init
                                                        then maybe noneNode id self
                                                        else @args.init
                                                else @exp.init
                             .final = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] 
                                          self      = callNode (new @args.label) scope @lhs.statNode [@name]
                                        in addMaybeNode self []
                             .nodes = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name]
                                          self      = callNode (new @args.label) scope @lhs.statNode [@name]
                                        in addMaybeNode self (@exp.nodes ++ @args.nodes)
                             .edges = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name]
                                        in -- Inter edge from the call to the entry.
                                           (addMaybeEdge (callEdge (new @args.label, scope) @lhs.methods)
                                           . -- Inter edge from the exit to the next node.
                                           addMaybeEdge (returnEdge (scope, new (new @args.label)) @lhs.methods))
                                           (@exp.edges ++ @args.edges)
                         exp .label = @lhs.label
                         args.label = @exp.label 

sem Lhs'
    | Name' lhs .init  = noneNode
                .final = []