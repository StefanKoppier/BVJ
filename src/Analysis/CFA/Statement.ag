--------------------------------------------------------------------------------
-- Statement control flow generation
--
-- This file is responsible for creating the control flow of statements.
--------------------------------------------------------------------------------

attr    MaybeCompoundStmts' CompoundStmts' CompoundStmt' Stmt' 
        SwitchBlocks' SwitchBlock' Catches' Catch'
    inh method                     :: Name'
    inh scopeEntries               :: {[BlockEntryType]}
    syn init                       :: {CFGNode}
    syn final                      :: {CFGNodes}
    syn breaks       use {++} {[]} :: {[(CFGNode, [BlockEntryType])]}
    syn continues    use {++} {[]} :: {[(CFGNode, [BlockEntryType])]}
--    syn returns      use {++} {[]} :: {[(CFGNode, [BlockEntryType])]}

attr    CompoundStmt'
    syn guard :: {CFGNode}

--------------------------------------------------------------------------------
-- Sequence of statements.
--------------------------------------------------------------------------------

sem CompoundStmts'
    | Cons  lhs .label = @tl.label
                .init  = @hd.init
                .final = ifNoneNodes @tl.final @hd.final
                .edges = case @hd.self of
                            Stmt' (Break' _)
                                -> @hd.edges
                            Stmt' (Continue' _)
                                -> @hd.edges
                            Block' _ _
                                -> @hd.edges ++ @tl.edges
                                   ++ -- Edges from the final to the next statement.
                                   blockExitEdges (@hd.final, @tl.init) (BlockEntryType Nothing)
                            IfThenElse' _ _ _
                                -> @hd.edges ++ @tl.edges 
                                   ++ -- Edges from the final to the next statement.
                                   blockExitEdges (@hd.final, @tl.init) (ConditionalEntryType Nothing)
                            While' _ guard _
                                -> @hd.edges ++ @tl.edges
                                   ++ -- Edge from the guard to the next statement.
                                   blockExitEdge (@hd.guard, @tl.init) (ConditionalEntryType (Just (PreNot' guard)))
                                   ++ -- Edges from the breaks to the next statement.
                                   breakExitEdges (@hd.breaks, @tl.init)
                            _   
                                -> @hd.edges ++ @tl.edges 
                                   ++ seqEdges (@hd.final, @tl.init) (Just @hd.self) @tl.self
                .nodes = @hd.nodes ++ @tl.nodes
                .breaks = case @hd.self of
                            While' ident _ _ -> (filter (not . isLabelOfThisNode ident . fst) @hd.breaks) ++ @tl.breaks
                            _                -> @hd.breaks ++ @tl.breaks
            hd  .label = @lhs.label
                .scopeEntries = case @hd.self of 
                                    Block' _ _ -> (BlockEntryType Nothing) : @lhs.scopeEntries; 
                                    _          -> @lhs.scopeEntries
            tl  .label        = @hd.label
                .scopeEntries = @lhs.scopeEntries

    | Nil   lhs .init  = noneNode
                .final = noneNodes

sem MaybeCompoundStmts'
    | Just      lhs.label = @just.label
                   .init  = @just.init
                   .final = @just.final

    | Nothing   lhs.label = @lhs.label
                   .init  = noneNode
                   .final = noneNodes

--------------------------------------------------------------------------------
-- Compound statements.
--------------------------------------------------------------------------------

sem CompoundStmt'
    | Block'        lhs  .label         = @stat.label
                    stat .label         = @lhs.label
                         .scopeEntries  = @lhs.scopeEntries
      
    | IfThenElse'   lhs  .label     = @stat2.label
                         .init      = let self = statNode (new @exp.label) @self
                                        in ifNoneNode @exp.init self
                         .final     = @stat1.final ++ @stat2.final
                         .nodes     = let self = statNode (new @exp.label) @self
                                        in self : @exp.nodes ++ @stat1.nodes ++ @stat2.nodes
                         .edges     = let self = statNode (new @exp.label) @self
                                        in @stat1.edges ++ @stat2.edges ++ @exp.edges
                                           ++ -- Edge from condition to true branch.
                                           blockEntryEdge (self, @stat1.init) (ConditionalEntryType (Just @exp.self))
                                           ++ -- Edge from condition to false branch.
                                           blockEntryEdge (self, @stat2.init) (ConditionalEntryType (Just (PreNot' @exp.self)))
                    exp  .label     = @lhs.label
                         .statNode  = new @exp.label
                    stat1.label     = new @exp.label
                         .scopeEntries = ConditionalEntryType Nothing : @lhs.scopeEntries
                    stat2.label     = @stat1.label
                         .scopeEntries = ConditionalEntryType Nothing : @lhs.scopeEntries

    | While'        lhs .label      = @body.label
                        .init       = let self = statNode (new @exp.label) @self
                                        in ifNoneNode @exp.init self
                        .final      = let self = statNode (new @exp.label) @self
                                        in if null @exp.init then [self] else [@exp.init]
                        .nodes      = let self = statNode (new @exp.label) @self
                                        in self : @body.nodes ++ @exp.nodes
                        .edges      = let self      = statNode (new @exp.label) @self
                                          continues = filter (isLabelOfThisNode @ident . fst) @body.continues
                                          init      = ifNoneNode @exp.init self
                                        in @body.edges ++ @exp.edges
                                           ++ -- Edge from condition to the body.
                                           blockEntryEdge (self, @body.init) (ConditionalEntryType (Just @exp.self))
                                           ++ -- Edge from end of body to the condition.
                                           blockExitEdges (@body.final, init) (ConditionalEntryType Nothing)
                                           ++ -- Edge from continues of this loop to the condition.
                                           continueExitEdges (continues, init) @lhs.scopeEntries
                        .continues  = filter (not . isLabelOfThisNode @ident . fst) @body.continues
                        .guard      = statNode (new @exp.label) @self
                        .scopeEntries = @lhs.scopeEntries
                    exp .label      = @lhs.label
                        .statNode   = new @exp.label
                    body.label      = new @exp.label
                        .scopeEntries = ConditionalEntryType Nothing : @lhs.scopeEntries
{-
    | Switch'       lhs     .label     = @cases.label
                            .init      = let self = statNode (new @exp.label) @self
                                            in ifNoneNode @exp.init self 
                            .final     = @cases.final ++ filter (isLabelOfThisNode Nothing . fst) @cases.breaks 
                            .nodes     = let self    = statNode (new @exp.label) @self 
                                            in self : @exp.nodes ++ @cases.nodes
                            .edges     = [] -- @exp.edges ++ @cases.edges
                            .breaks    = filter (not . isLabelOfThisNode Nothing . fst) @cases.breaks
                    exp     .label     = @lhs.label
                            .statNode  = new @exp.label
                    cases   .label     = new @exp.label
                            .parent    = statNode (new @exp.label) @self
                            .guard     = @exp.self
                            .previous  = []
-}
    | Try'          lhs     .label  = @finally.label
                            .init   = statNode (new @lhs.label) @self
                            .final  = maybe @catches.final (const @finally.final) @finally.self
                            .nodes  = let self    = statNode (new @lhs.label) @self 
                                          finally = finallyNode (new @catches.label) @finally.self
                                        in addMaybeNode finally (self : @stat.nodes ++ @catches.nodes ++ @finally.nodes)
                            .edges  = let self    = statNode (new @lhs.label) @self
                                          finally = finallyNode (new @catches.label) @finally.self
                                        in @stat.edges ++ @catches.edges ++ @finally.edges
                                           ++ -- Edge from self to init of stat.
                                           blockEntryEdge (self, @stat.init) TryEntryType
                                           ++ -- Edge from stat to init of catches.
                                           blockExitEntryEdges (@stat.final, @catches.init) TryEntryType (CatchEntryType (Just @catches.exception))
                                           ++ -- Edge from last catch to finally, if it exists.
                                           maybe [] (\ finallyNode -> blockExitEntryEdges (@catches.final, finallyNode) (CatchEntryType Nothing) FinallyEntryType) finally
                                           ++ -- Edge from finally to body of finally, if it exists.
                                           maybe [] (\ finallyNode -> intraEdge (finallyNode, @finally.init)) finally
                    stat    .label  = new @lhs.label
                    catches .label  = @stat.label
                    finally .label  = maybe @catches.label (const (new @catches.label)) @finally.self

attr    SwitchBlocks'
    inh parent   :: {CFGNode}
    inh guard    :: Exp'
    inh previous :: SwitchBlocks'
                    
sem SwitchBlocks'
    | Cons lhs  .init       = @hd.init
                .edges      = []
                    {- -- Edges from expression to each case.
                          condEdge @lhs.parent @hd.init (caseCondExp @lhs.guard @lhs.previous @hd.self) 1 
                          ++ -- Edges from final of case to init of the next.
                          (if noNode == @tl.init
                               then [] else intraEdges @hd.final @tl.init 0)
                          -- Edges from the body and rest of the list. 
                          ++ @hd.edges ++ @tl.edges-}
           tl   .previous   = @hd.self : @lhs.previous 

    | Nil  lhs  .init       = noneNode
                .final      = noneNodes
              
sem SwitchBlock'
    | SwitchBlock' lhs.init  = @stat.init
                      .final = @stat.final

attr    Catches' 
    syn exception :: {FormalParam'}

sem Catches'
    | Cons  lhs .label      = if @tl.init == noneNode then @hd.label else @tl.label
                .init       = @hd.init
                .final      = ifNoneNodes @tl.final @hd.final
                .exception  = getException @hd.self
                .edges      = @hd.edges ++ @tl.edges
                              ++ if noneNode == @tl.init
                                    then []
                                    else blockExitEntryEdges (@hd.final, @tl.init) (CatchEntryType Nothing) (CatchEntryType (Just @tl.exception))
            hd  .label      = @lhs.label

    | Nil   lhs .init   = noneNode
                .final  = noneNodes

sem Catch'
    | Catch'    lhs .label      = @body.label
                    .init       = catchNode (new @lhs.label) @self
                    .final      = @body.final
                    .nodes      = let self = catchNode (new @lhs.label) @self 
                                    in self : @body.nodes
                    .edges      = let self = catchNode (new @lhs.label) @self 
                                    in @body.edges
                                       ++ -- Edge from catch to stat
                                       intraEdge (self, @body.init)
                body.label      = new @lhs.label

{
getException :: Catch' -> FormalParam'
getException (Catch' e _) = e
}

--------------------------------------------------------------------------------
-- Statements.
--------------------------------------------------------------------------------

sem Stmt'
    | Decl'     lhs .label      = new @vars.label
                    .init       = let self = statNode (new @vars.label) (Stmt' @self)
                                    in ifNoneNode @vars.init self 
                    .final      = [statNode (new @vars.label) (Stmt' @self)]
                    .nodes      = let self = statNode (new @vars.label) (Stmt' @self)
                                    in self : @vars.nodes
                    .edges      = @vars.edges
                vars.label      = @lhs.label
                vars.statNode   = 1 + @lhs.label + @vars.numberOfCalls

    | Empty'    lhs .label      = new @lhs.label
                    .init       = statNode (new @lhs.label) (Stmt' @self)
                    .final      = [statNode (new @lhs.label) (Stmt' @self)]
                    .nodes      = [statNode (new @lhs.label) (Stmt' @self)]

    | ExpStmt'  lhs .label      = new @exp.label
                    .init       = let self = statNode (new @exp.label) (Stmt' @self)
                                    in ifNoneNode @exp.init self
                    .final      = [statNode (new @exp.label) (Stmt' @self)]
                    .nodes      = let self = statNode (new @exp.label) (Stmt' @self)
                                    in self : @exp.nodes
                    .edges      = @exp.edges
                exp .label      = @lhs.label
                exp .statNode   = 1 + @lhs.label + @exp.numberOfCalls

    | Assert'   lhs .label      = new @exp.label
                    .init       = let self = statNode (new @exp.label) (Stmt' @self)
                                    in ifNoneNode @exp.init self 
                    .final      = [statNode (new @exp.label) (Stmt' @self)]
                    .nodes      = let self = statNode (new @exp.label) (Stmt' @self)
                                    in self : @exp.nodes
                    .edges      = @exp.edges
                exp .label      = @lhs.label
                exp .statNode   = 1 + @lhs.label + @exp.numberOfCalls

    | Assume'   lhs .label      = new @exp.label
                    .init       = let self = statNode (new @exp.label) (Stmt' @self)
                                    in ifNoneNode @exp.init self 
                    .final      = [statNode (new @exp.label) (Stmt' @self)]
                    .nodes      = let self = statNode (new @exp.label) (Stmt' @self)
                                    in self : @exp.nodes
                    .edges      = @exp.edges
                exp .label      = @lhs.label
                exp .statNode   = 1 + @lhs.label + @exp.numberOfCalls

    | Break'    lhs .label      = new @lhs.label
                    .init       = statNode (new @lhs.label) (Stmt' @self)
                    .final      = []
                    .nodes      = [statNode (new @lhs.label) (Stmt' @self)]
                    .breaks     = [(statNode (new @lhs.label) (Stmt' @self), @lhs.scopeEntries)]

    | Continue' lhs .label      = new @lhs.label
                    .init       = statNode (new @lhs.label) (Stmt' @self)
                    .final      = []
                    .nodes      = [statNode (new @lhs.label) (Stmt' @self)]
                    .continues  = [(statNode (new @lhs.label) (Stmt' @self), @lhs.scopeEntries)]

    | Return'   lhs .label      = new @exp.label
                    .init       = let self = statNode (new @exp.label) (Stmt' @self)
                                    in ifNoneNode @exp.init self 
                    .final      = [statNode (new @exp.label) (Stmt' @self)]
                    .nodes      = let self = statNode (new @exp.label) (Stmt' @self)
                                    in self : @exp.nodes
                    .edges      = @exp.edges
                --    .returns    = [(statNode (new @exp.label) (Stmt' @self), @lhs.scopeEntries)]
                exp .label      = @lhs.label
                    .statNode   = 1 + @lhs.label + @exp.numberOfCalls

    | Throw'    lhs .label      = new @exp.label
                    .init       = let self = statNode (new @exp.label) (Stmt' @self)
                                    in ifNoneNode @exp.init self 
                    .final      = let self = statNode (new @exp.label) (Stmt' @self)
                                    in if null @exp.final then [self] else @exp.final
                    .nodes      = let self = statNode (new @exp.label) (Stmt' @self)
                                    in self : @exp.nodes
                    .edges      = @exp.edges
                exp .label      = @lhs.label
                    .statNode   = 1 + @lhs.label + @exp.numberOfCalls

sem VarDecls'
    | Cons      lhs .init   = ifNoneNode @hd.init @tl.init

    | Nil       lhs .init   = noneNode
                    .final  = noneNodes

sem VarDecl'
    | VarDecl'  lhs .label  = @init.label
                    .init   = @init.init
                    .final  = @init.final

sem VarInits'
    | Cons      lhs .init   = ifNoneNode @hd.init @tl.init

    | Nil       lhs .init   = noneNode
                    .final  = noneNodes

sem MaybeVarInits'
    | Nothing   lhs .init   = noneNode
                    .final  = noneNodes
