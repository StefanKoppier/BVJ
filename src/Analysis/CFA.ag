data Node
    | NodeStmt      label :: {Label}
                    value  :: Stmt'

    | NodeVarDecl   label :: {Label}
                    value :: BlockStmt'

    | NodeForInit   label :: {Label}
                    value :: {ForInit}

    | NodeForUpdate label :: {Label}
                    value :: {[Exp]}
deriving  Node : Eq

type Nodes = [Node]

attr Node
    syn label :: {Label}

attr Block' BlockStmts' BlockStmt' Stmt'
    syn nodes   use {++} {[]}       :: {Nodes}
    syn flow    use {<>} {mempty}   :: {Flow}
    syn init                        :: {Label}
    syn final                       :: {Labels}
    inh next                        :: {Maybe Label}
    chn label                       :: {Label}

sem Block'
    | Block' lhs.label = @blocks.label

sem BlockStmts'
    | Seq'  lhs  .label = @stat2.label
                 .init  = @stat1.init
                 .final = @stat2.final
                 .flow  = @stat1.flow <> intraEdges @stat1.final @stat2.init <> @stat2.flow
            stat1.label = @lhs.label
            stat1.next  = Just @stat2.init
            stat2.label = @stat1.label

    | Single' lhs.flow = @s.flow

sem BlockStmt'
    | LocalVars' lhs.label = new @lhs.label
                    .nodes = [NodeVarDecl (new @lhs.label) @self]
                    .init  = new @lhs.label
                    .final = [new @lhs.label]

sem Stmt'
    | StmtBlock'    lhs.label = @block.label
                       .init  = @block.init
                       .final = @block.final
                       .flow  = @block.flow

    | IfThen'       lhs .label = @stat.label
                        .nodes = (node (new @lhs.label) @self) : @stat.nodes
                        .init  = new @lhs.label
                        .final = @stat.final
                        .flow  = (intraEdge (new @lhs.label) @stat.init) <> @stat.flow
                    stat.label = new @lhs.label

    | IfThenElse'   lhs  .label = @stat2.label
                         .nodes = (node (new @lhs.label) @self) : (@stat1.nodes ++ @stat2.nodes)
                         .init  = new @lhs.label
                         .final = @stat1.final ++ @stat2.final
                         .flow  = (intraEdge (new @lhs.label) @stat1.init) <> 
                                  (intraEdge (new @lhs.label) @stat2.init) <> 
                                  @stat1.flow                              <> 
                                  @stat2.flow
                    stat1.label = new @lhs.label
                    stat2.label = @stat1.label

    | While'        lhs .label     = @body.label
                        .nodes     = (node (new @lhs.label) @self) : @body.nodes
                        .init      = new @lhs.label
                        .final     = [new @lhs.label]
                        .flow      = (intraEdge (new @lhs.label) @body.init)   <> 
                                     @body.flow                                <> 
                                     (intraEdges @body.final (new @lhs.label))
                    body.label     = new @lhs.label

    | BasicFor'     lhs .label = @body.label
                        .nodes = [node (new @lhs.label) @self]              ++ -- Condition node
                                 (forInitNode (new $ new @lhs.label) @init) ++ -- Initialisation node
                                 @body.nodes                                ++ -- body nodes
                                 (forUpdateNode (new $ new $ newIfJust @init @lhs.label) @update) --update node
                        .init  = new $ newIfJust @init @lhs.label -- Initialisation if it exists, otherwise the condition
                        .final = [new @lhs.label] -- Condition
                        .flow  = maybe mempty (const $ intraEdge (new $ new @lhs.label) (new @lhs.label)) @init <> -- Initialisation -> Condition
                                 intraEdge (new @lhs.label) @body.init <> -- Condition -> Body
                                 intraEdges @body.final (maybe (new @lhs.label) (const $ new $ new $ newIfJust @init @lhs.label) @update) <> -- Body -> Update/Condition
                                 maybe mempty (const $ intraEdge (new $ new $ newIfJust @init @lhs.label) (new @lhs.label)) @update <> -- Update -> Condition
                                 @body.flow 
                    body.label = new $ newIfJust @init $ newIfJust @update @lhs.label

    | Empty'        lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | ExpStmt'      lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Assert'       lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Break'        lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]
        
    | Continue'     lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Return'       lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Labeled'      lhs  .label     = @stat.label
                         .nodes     = @stat.nodes
                         .init      = @stat.init
                         .final     = @stat.final

{
new :: Label -> Label
new = (1+)

newIfJust :: Maybe a -> Label -> Label
newIfJust (Just _) = new
newIfJust Nothing  = id

node :: Label -> Stmt' -> Node
node l s = NodeStmt l s

forInitNode :: Label -> Maybe ForInit -> [Node]
forInitNode l (Just i) = [NodeForInit l i]
forInitNode _ Nothing  = []

forUpdateNode :: Label -> Maybe [Exp] -> [Node]
forUpdateNode l (Just es) = [NodeForUpdate l es]
forUpdateNode _ Nothing   = []

flowOfBlock :: Block' -> Flow
flowOfBlock block
    = flow_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block'     = 0
                             , next_Inh_Block'      = Nothing } 
        
nodesOfBlock :: Block' -> Nodes
nodesOfBlock block
    = nodes_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block'     = 0
                             , next_Inh_Block'      = Nothing } 

instance Show Node where
    show (NodeStmt l s)      = show l ++ ": " ++ show s
    show (NodeVarDecl l s)   = show l ++ ": " ++ show s
    show (NodeForInit l s)   = show l ++ ": " ++ show s
    show (NodeForUpdate l s) = show l ++ ": " ++ show s
}
