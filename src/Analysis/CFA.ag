imports {
import qualified Data.Map                          as M
import           Analysis.CFG
import           Data.Graph.Inductive.Graph    
import           Parsing.Syntax

import Debug.Trace
}

include "../Parsing/Syntax.ag"

attr CompilationUnit' TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmt' Stmt'  SwitchBlocks' SwitchBlock'
    syn nodes use {++} {[]} :: {CFGNodes}
    syn edges use {++} {[]} :: {CFGEdges}
    chn label               :: {Node}

--------------------------------------------------------------------------------
-- Files
--------------------------------------------------------------------------------

attr CompilationUnit'
    syn cfg :: {CFG}

sem CompilationUnit'
    | CompilationUnit' lhs.cfg = constructCFG @decls.nodes @decls.edges

--------------------------------------------------------------------------------
-- Methods
--------------------------------------------------------------------------------

attr CompilationUnit' TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl'
    syn methods use {M.union} {M.empty} :: {Methods} 

sem MemberDecl'
    | MethodDecl'       lhs .label   = new @body.label
                            .methods = M.singleton [@name] (new @lhs.label, new @body.label)
                            .nodes   = -- Entry node of the method.
                                       entry (new @lhs.label) [@name]
                                       : -- Exit node of the method.
                                       exit (new @body.label) [@name]
                                       : -- Nodes of the body.
                                       @body.nodes
                            .edges   = let entry' = entry (new @lhs.label) [@name]
                                           exit'  = exit (new @body.label) [@name] in
                                           -- Edge from entry of method to body.
                                           intraEdge entry' @body.init
                                           : -- Edge(s) from final of body to exit of method.
                                           intraEdges @body.final exit'
                                           ++ -- Edge(s) from returns to exit of method.
                                           intraEdges @body.returns exit'
                                           ++ -- Edges of the body.
                                           @body.edges
                        body.label   = new @lhs.label
                            .method  = [@name]

    | ConstructorDecl'  lhs .label   = new @body.label
                            .methods = M.singleton [@name] (new @lhs.label, new @body.label)
                            .nodes   = -- Entry node of the method.
                                       entry (new @lhs.label) [@name]
                                       : -- Exit node of the method.
                                       exit (new @body.label) [@name]
                                       : -- Nodes of the body.
                                       @body.nodes
                            .edges   = let entry' = entry (new @lhs.label) [@name]
                                           exit'  = exit (new @body.label) [@name] in
                                           -- Edge from entry of method to body.
                                           intraEdge entry' @body.init
                                           : -- Edge(s) from final of body to exit of method.
                                           intraEdges @body.final exit'
                                           ++ -- Edge(s) from returns to exit of method.
                                           intraEdges @body.returns exit'
                                           ++ -- Edges of the body.
                                           @body.edges
                        body.label   = new @lhs.label
                            .method  = [@name]

attr TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmt' Stmt' 
     SwitchBlocks' SwitchBlock' Exps' Exp' MethodInvocation' VarDecls' VarDecl' VarInit'
    inh methods :: {Methods}

sem CompilationUnit'
    | CompilationUnit' decls.methods = @decls.methods

sem MemberDecl'
    | MethodDecl'      body.methods = M.insert [@name] (new @lhs.label, new @body.label) @lhs.methods
    
    | ConstructorDecl' body.methods = M.insert [@name] (new @lhs.label, new @body.label) @lhs.methods

--------------------------------------------------------------------------------
-- Statements
--------------------------------------------------------------------------------

attr CompoundStmt' Stmt' SwitchBlocks' SwitchBlock'
    inh method                  :: Name'
    syn init                    :: {CFGNode}
    syn final                   :: {CFGNodes}
    syn breaks    use {++} {[]} :: {CFGNodes}
    syn continues use {++} {[]} :: {CFGNodes}
    syn returns   use {++} {[]} :: {CFGNodes}

attr CompoundStmt'
    syn guard :: {CFGNode}

sem CompoundStmt'
    | Seq'          lhs  .label = @stat2.label
                         .init  = @stat1.init
                         .final = @stat2.final
                         .edges = case @stat1.self of
                                    While' _ e _
                                       -> let conditional = @stat1.guard  -- + number of invocations
                                              normal      = filter (conditional /=) @stat1.final in
                                              condEdge conditional @stat2.init (PreNot' e)
                                              :
                                              intraEdges normal @stat2.init
                                              ++
                                              @stat1.edges ++ @stat2.edges
                                    Stmt' (Break' _)
                                       -> @stat1.edges
                                    Stmt' (Continue' _)
                                       -> @stat1.edges
                                    Stmt' (ReturnExp' _)
                                       -> @stat1.edges
                                    Stmt' Return'
                                       -> @stat1.edges
                                    _  -> @stat1.edges ++ @stat2.edges ++
                                          intraEdges @stat1.final @stat2.init
                    stat1.label = @lhs.label
                    stat2.label = @stat1.label
      
    | IfThenElse'   lhs  .label = @stat2.label
                         .init  = if noNode == @exp.init 
                                     then (block (new @exp.label) @self)
                                     else @exp.init
                         .final = @stat1.final ++ @stat2.final
                         .nodes = block (new @exp.label) @self 
                                  : @exp.nodes ++ @stat1.nodes ++ @stat2.nodes
                         .edges = let self = block (new @exp.label) @self in
                                    -- Edge from condition to init of true branch.
                                    condEdge self @stat1.init @exp.self
                                    : -- Edge from condition to init of false branch.
                                    condEdge self @stat2.init (PreNot' @exp.self)
                                    : -- Edge(s) of the branches.
                                    @stat1.edges ++ @stat2.edges ++ @exp.edges
                    exp  .label = @lhs.label
                    stat1.label = new @exp.label
                    stat2.label = @stat1.label

    | While'        lhs .label     = @body.label
                        .init      = if noNode == @exp.init 
                                        then (block (new @exp.label) @self)
                                        else @exp.init
                        .final     = block (new @exp.label) @self : filter (isLabelOfThisNode @ident) @body.breaks
                        .nodes     = block (new @exp.label) @self : @body.nodes ++ @exp.nodes
                        .edges     = let self = block (new @exp.label) @self
                                         init = if noNode == @exp.init
                                                    then self else @exp.init in
                                         -- Edge from condition to the init body.
                                         condEdge self @body.init (@exp.self)
                                         : -- Edge(s) from finals of body to the condition.
                                         intraEdges @body.final init
                                         ++ -- Edge(s) from continues of this loop to the condition.
                                         intraEdges (filter (isLabelOfThisNode @ident) @body.continues) init
                                         ++ -- Edge(s) of the body.
                                         @body.edges ++ @exp.edges
                        .breaks    = filter (not . isLabelOfThisNode @ident) @body.breaks
                        .continues = filter (not . isLabelOfThisNode @ident) @body.continues
                        .guard     = block (new @exp.label) @self
                    exp .label     = @lhs.label
                    body.label     = new @exp.label

    | Switch'       lhs  .label    = @cases.label
                         .init     = block (new @lhs.label) @self
                         .final    = @cases.final ++ filter (isLabelOfThisNode Nothing) @cases.breaks 
                         .nodes    = block (new @lhs.label) @self : @cases.nodes
                         .edges    = @cases.edges
                         .breaks   = filter (not . isLabelOfThisNode Nothing) @cases.breaks
                    cases.label    = new @lhs.label
                         .parent   = block (new @lhs.label) @self
                         .guard    = @exp.self
                         .previous = []

attr SwitchBlocks'
    inh parent   :: {CFGNode}
    inh guard    :: Exp'
    inh previous :: SwitchBlocks'
                    
sem SwitchBlocks'
    | Cons lhs.init     = @hd.init
              .edges    = -- Edges from expression to each case.
                          condEdge @lhs.parent @hd.init (caseCondExp @lhs.guard @lhs.previous @hd.self) 
                          : -- Edges from final of case to init of the next.
                          (if @tl.init == noNode
                               then [] else intraEdges @hd.final @tl.init)
                          -- Edges from the body and rest of the list. 
                          ++ @hd.edges ++ @tl.edges
           tl .previous = @hd.self : @lhs.previous 

    | Nil  lhs.final    = []
              .init     = noNode

sem SwitchBlock'
    | SwitchBlock' lhs.init  = @stat.init
                      .final = @stat.final

sem Stmt'
    | Decl'     lhs .label = new @vars.label
                    .init  = if noNode == @vars.init 
                                then (block (new @vars.label) (Stmt' @self))
                                else @vars.init
                    .final = [block (new @vars.label) (Stmt' @self)]
                    .nodes = block (new @vars.label) (Stmt' @self) : @vars.nodes
                    .edges = @vars.edges
                vars.label = @lhs.label

    | Empty'    lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]

    | ExpStmt'  lhs .label = new @exp.label
                    .init  = if noNode == @exp.init 
                                then (block (new @exp.label) (Stmt' @self))
                                else @exp.init
                    .final = [block (new @exp.label) (Stmt' @self)]
                    .nodes = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges = @exp.edges
                exp .label = @lhs.label

-- TODO: change assert error to string?
    | Assert'   lhs .label = new @exp.label
                    .init  = if noNode == @exp.init 
                                then (block (new @exp.label) (Stmt' @self))
                                else @exp.init
                    .final = [block (new @exp.label) (Stmt' @self)]
                    .nodes = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges = @exp.edges
                exp .label = @lhs.label

    | Assume'   lhs .label = new @exp.label
                    .init  = if noNode == @exp.init 
                                then (block (new @exp.label) (Stmt' @self))
                                else @exp.init
                    .final = [block (new @exp.label) (Stmt' @self)]
                    .nodes = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges = @exp.edges
                exp .label = @lhs.label

    | Break'    lhs .label  = new @lhs.label
                    .init   = block (new @lhs.label) (Stmt' @self)
                    .final  = []
                    .nodes  = [block (new @lhs.label) (Stmt' @self)]
                    .breaks = [block (new @lhs.label) (Stmt' @self)]

    | Continue' lhs .label     = new @lhs.label
                    .init      = block (new @lhs.label) (Stmt' @self)
                    .final     = []
                    .nodes     = [block (new @lhs.label) (Stmt' @self)]
                    .continues = [block (new @lhs.label) (Stmt' @self)]

    | ReturnExp'    lhs .label   = new @exp.label
                        .init    = if noNode == @exp.init
                                      then (block (new @exp.label) (Stmt' @self))
                                      else @exp.init
                        .final   = []
                        .nodes   = block (new @exp.label) (Stmt' @self) : @exp.nodes
                        .edges   = @exp.edges
                        .returns = [block (new @exp.label) (Stmt' @self)]
                    exp .label   = @lhs.label

    | Return'   lhs .label   = new @lhs.label
                    .init    = block (new @lhs.label) (Stmt' @self)
                    .final   = []
                    .nodes   = [block (new @lhs.label) (Stmt' @self)]
                    .returns = [block (new @lhs.label) (Stmt' @self)]

--------------------------------------------------------------------------------
-- Expressions and variable declarations
--------------------------------------------------------------------------------

attr Exps' Exp' VarDecls' VarDecl' VarInit' MethodInvocation'
    chn label               :: {Node}
    syn init                :: {CFGNode}
    syn final               :: {CFGNodes}
    syn nodes use {++} {[]} :: {CFGNodes}
    syn edges use {++} {[]} :: {CFGEdges}

sem Exps'
    | Cons      lhs.init  = if noNode == @hd.init
                                then @tl.init
                                else @hd.init
                   .final = if null @tl.final
                                then @hd.final
                                else @tl.final
    | Nil       lhs.init  = noNode
                   .final = [] 

{
nameOfClassType :: ClassType' -> Name'
nameOfClassType (ClassType' n) = n
}

sem Exp'
    | Lit'              lhs .label  = @lhs.label
                            .init   = noNode
                            .final  = []

    | InstanceCreation' lhs .label = new @args.label
                            .init  = if noNode == @args.init
                                        then call (new @args.label) (nameOfClassType @ty.self)
                                        else @args.init 
                            .final = [call (new @args.label) (nameOfClassType @ty.self)]
                            .nodes = call (new @args.label) (nameOfClassType @ty.self) : @args.nodes
                            .edges = -- Inter edge from the call to the entry
                                     callEdge (new @args.label, (nameOfClassType @ty.self)) @lhs.methods
                                     : -- Inter edge from the exit to the next node
                                     returnEdge ((nameOfClassType @ty.self), new (new @args.label))  @lhs.methods
                                     : @args.edges
                        args.label = @lhs.label

    | ExpName'          lhs .label  = @lhs.label
                            .init   = noNode
                            .final  = []

    | BinOp'            lhs .label   = @exp2.label
                            .init    = if noNode == @exp1.init
                                        then @exp2.init
                                        else @exp1.init
                            .final  = if null @exp2.final
                                        then @exp1.final
                                        else @exp2.final
                            .edges  = @exp1.edges ++ @exp2.edges
                        exp1.label = @lhs.label
                        exp2.label = @exp1.label

    | Cond'             lhs .label = @e2.label
                            .init  = if noNode == @guard.init
                                        then if noNode == @e1.init
                                                then @e2.init
                                                else @e1.init
                                        else @guard.init
                            .final = if null @e2.final
                                        then if null @e1.final
                                                then @guard.final
                                                else @e2.final
                                        else @e1.final
                        guard.label = @lhs.label
                        e1   .label = @guard.label
                        e2   .label = @e1.label

sem MethodInvocation'
    | MethodCall' lhs.label  = new @args.label
                     .init   = if noNode == @args.init
                                    then call (new @args.label) @name.self
                                    else @args.init
                     .final  = [call (new @args.label) @name.self]
                     .nodes  = call (new @args.label) @name.self : @args.nodes
                     .edges  = -- Inter edge from the call to the entry
                               callEdge (new @args.label, @name.self) @lhs.methods
                               : -- Inter edge from the exit to the next node
                               returnEdge (@name.self, new (new @args.label))  @lhs.methods
                               -- The edges of the call arguments.
                               : @args.edges
                  args.label = @lhs.label

sem VarDecls'
    | Cons      lhs.init  = if noNode == @hd.init then @tl.init else @hd.init
    | Nil       lhs.init  = noNode
                   .final = []

sem VarDecl'
    | VarDecl'  lhs.label = @init.label
                   .init  = @init.init
                   .final = @init.final

--------------------------------------------------------------------------------
-- Auxiliary functions
--------------------------------------------------------------------------------

{
type Methods = M.Map Name' (Node, Node)

caseCondExp :: Exp' -> [SwitchBlock'] -> SwitchBlock' -> Exp'
caseCondExp e1 previous (SwitchBlock' Nothing _)   
    = let exps = [e | (SwitchBlock' (Just e) _) <- previous]
       in foldr (\ e -> BinOp' (BinOp' e1 NotEq' e) CAnd') (Lit' (Boolean' True)) exps
caseCondExp e1 _ (SwitchBlock' (Just e2) _) 
    = BinOp' e1 Equal' e2

noNode :: (Node, CFGNodeValue)
noNode = (-1, undefined)

new :: Node -> Node
new = (1+)

newIfJust :: Maybe a -> Node -> Node
newIfJust = maybe id (const new)

call :: Node -> Name' -> CFGNode
call n name = (n, Call name)

block :: Node -> CompoundStmt' -> CFGNode
block n s = (n, Block s)

entry :: Node -> Name' -> CFGNode
entry n name = (n, Entry name)

exit :: Node -> Name' -> CFGNode
exit n name =  (n, Exit name)

intraEdge :: CFGNode -> CFGNode -> CFGEdge
intraEdge (x,_) (y,_) = (x, y, IntraEdge)

intraEdges :: CFGNodes -> CFGNode -> CFGEdges
intraEdges xs y 
    | noNode == y = []
    | otherwise   = map (`intraEdge` y) xs

callEdge :: (Node, Name') -> Methods -> CFGEdge
callEdge (node,name) methods 
    = let name' = [last name] 
       in ((node, fst (methods M.! name'), InterEdge name'))

returnEdge :: (Name',Node) -> Methods -> CFGEdge
returnEdge (name,node) methods 
    = let name' = [last name] 
       in (snd (methods M.! name'), node, InterEdge name')

condEdge :: CFGNode -> CFGNode -> Exp' -> CFGEdge
condEdge (x,_) (y,_) e = (x, y, ConditionalEdge e)

isLabelOfThisNode :: Maybe String -> CFGNode -> Bool
isLabelOfThisNode _        (_, Block (Stmt' (Break' Nothing)))      = True
isLabelOfThisNode _        (_, Block (Stmt' (Continue' Nothing)))   = True
isLabelOfThisNode Nothing  (_, Block (Stmt' (Break' (Just _))))     = False
isLabelOfThisNode Nothing  (_, Block (Stmt' (Continue' (Just _))))  = False
isLabelOfThisNode (Just l) (_, Block (Stmt' (Break' (Just l'))))    = l == l'
isLabelOfThisNode (Just l) (_, Block (Stmt' (Continue' (Just l')))) = l == l'
isLabelOfThisNode _        _                                        = error "Not a break or continue statement."

cfgOfCompilationUnit :: CompilationUnit' -> CFG
cfgOfCompilationUnit unit
    = cfg_Syn_CompilationUnit' $ wrap_CompilationUnit' (sem_CompilationUnit' unit) initial
    where
        initial = Inh_CompilationUnit' { label_Inh_CompilationUnit' = 0 }
}