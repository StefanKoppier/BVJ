imports {
import qualified Data.Map                          as M
import           Analysis.CFG
import           Data.Graph.Inductive.Graph    
import           Parsing.Syntax
}

include "../Parsing/Syntax.ag"

attr CompilationUnit' TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmt' Stmt'  SwitchBlocks' SwitchBlock'
    syn nodes use {++} {[]} :: {CFGNodes}
    syn edges use {++} {[]} :: {CFGEdges}
    chn label               :: {Node}

--------------------------------------------------------------------------------
-- Files
--------------------------------------------------------------------------------

attr CompilationUnit'
    syn cfg :: {CFG}

sem CompilationUnit'
    | CompilationUnit' lhs.cfg = constructCFG @decls.nodes @decls.edges

--------------------------------------------------------------------------------
-- Methods
--------------------------------------------------------------------------------

attr CompilationUnit' TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl'
    syn methods use {M.union} {M.empty} :: {Methods} 

sem MemberDecl'
    | MethodDecl'       lhs .label   = new @body.label
                            .methods = M.singleton [@name] (new @lhs.label, new @body.label)
                            .nodes   = -- Entry node of the method.
                                       entry (new @lhs.label) [@name]
                                       : -- Exit node of the method.
                                       exit (new @body.label) [@name]
                                       : -- Nodes of the body.
                                       @body.nodes
                            .edges   = let entry' = entry (new @lhs.label) [@name]
                                           exit'  = exit (new @body.label) [@name] in
                                           -- Edge from entry of method to body.
                                           newIntraEdge entry' @body.init
                                           : -- Edge(s) from final of body to exit of method.
                                           newIntraEdges @body.final exit'
                                           ++ -- Edge(s) from returns to exit of method.
                                           newIntraEdges @body.returns exit'
                                           ++ -- Edges of the body.
                                           @body.edges
                        body.label   = new @lhs.label
                            .method  = [@name]

    | ConstructorDecl'  lhs .label   = new @body.label
                            .methods = M.singleton [@name] (new @lhs.label, new @body.label)
                            .nodes   = -- Entry node of the method.
                                       entry (new @lhs.label) [@name]
                                       : -- Exit node of the method.
                                       exit (new @body.label) [@name]
                                       : -- Nodes of the body.
                                       @body.nodes
                            .edges   = let entry' = entry (new @lhs.label) [@name]
                                           exit'  = exit (new @body.label) [@name] in
                                           -- Edge from entry of method to body.
                                           newIntraEdge entry' @body.init
                                           : -- Edge(s) from final of body to exit of method.
                                           newIntraEdges @body.final exit'
                                           ++ -- Edge(s) from returns to exit of method.
                                           newIntraEdges @body.returns exit'
                                           ++ -- Edges of the body.
                                           @body.edges
                        body.label   = new @lhs.label
                            .method  = [@name]

attr TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmt' Stmt'  SwitchBlocks' SwitchBlock'
    inh methods :: {Methods}

sem CompilationUnit'
    | CompilationUnit' decls.methods = @decls.methods

sem MemberDecl'
    | MethodDecl'      body.methods = M.insert [@name] (new @lhs.label, new @body.label) @lhs.methods
    
    | ConstructorDecl' body.methods = M.insert [@name] (new @lhs.label, new @body.label) @lhs.methods

--------------------------------------------------------------------------------
-- Statements
--------------------------------------------------------------------------------

attr CompoundStmt' Stmt' SwitchBlocks' SwitchBlock'
    inh method                  :: Name'
    syn init                    :: {CFGNode}
    syn final                   :: {CFGNodes}
    syn breaks    use {++} {[]} :: {CFGNodes}
    syn continues use {++} {[]} :: {CFGNodes}
    syn returns   use {++} {[]} :: {CFGNodes}

sem CompoundStmt'
    | Seq'          lhs  .label = @stat2.label
                         .init  = @stat1.init
                         .final = @stat2.final
                         .edges = case @stat1.self of
                                    While' _ e _
                                       -> let conditional = @stat1.init
                                              normal      = filter (conditional /=) @stat1.final in
                                              newCondEdge conditional @stat2.init (PreNot' e)
                                              :
                                              newIntraEdges normal @stat2.init
                                              ++
                                              @stat1.edges ++ @stat2.edges
                                    Stmt' (Break' _)
                                       -> @stat1.edges
                                    Stmt' (Continue' _)
                                       -> @stat1.edges
                                    Stmt' (Return' _)
                                       -> @stat1.edges
                                    _  -> @stat1.edges ++ @stat2.edges ++
                                          newIntraEdges @stat1.final @stat2.init
                    stat1.label = @lhs.label
                    stat2.label = @stat1.label
                         
    | IfThenElse'   lhs  .label = @stat2.label
                         .init  = block (new @lhs.label) @self
                         .final = @stat1.final ++ @stat2.final
                         .nodes = block (new @lhs.label) @self : @stat1.nodes ++ @stat2.nodes
                         .edges = let self = block (new @lhs.label) @self in       
                                      -- Edge from condition to init of true branch.
                                      newCondEdge self @stat1.init (@exp.self)
                                      : -- Edge from condition to init of false branch.
                                      newCondEdge self @stat2.init (PreNot' @exp.self)
                                      : -- Inter edge(s) from condition to entries and back.
                                      createInterEdges (new @lhs.label) @lhs.method @lhs.methods @exp.invocations
                                      ++ -- Edge(s) of the branches.
                                      @stat1.edges ++ @stat2.edges
                    stat1.label = new @lhs.label
                    stat2.label = @stat1.label

    | While'        lhs .label     = @body.label
                        .init      = block (new @lhs.label) @self
                        .final     = block (new @lhs.label) @self : filter (isLabelOfThisLoop @ident) @body.breaks
                        .nodes     = block (new @lhs.label) @self : @body.nodes
                        .edges     = let self = block (new @lhs.label) @self in
                                         -- Edge from condition to the init body.
                                         newCondEdge self @body.init (@exp.self)
                                         : -- Edge(s) from finals of body to the condition.
                                         newIntraEdges @body.final self
                                         ++ -- Edge(s) from continues of this loop to the condition.
                                         newIntraEdges (filter (isLabelOfThisLoop @ident) @body.continues) self
                                         ++ -- Inter edge(s) from condition to entries and back.
                                         createInterEdges (new @lhs.label) @lhs.method @lhs.methods @exp.invocations
                                         ++ -- Edge(s) of the body.
                                         @body.edges
                        .breaks    = filter (not . isLabelOfThisLoop @ident) @body.breaks
                        .continues = filter (not . isLabelOfThisLoop @ident) @body.continues
                    body.label     = new @lhs.label

    | Switch'       lhs  .label    = @cases.label
                         .init     = block (new @lhs.label) @self
                         .final    = @cases.final ++ filter (isLabelOfThisLoop Nothing) @cases.breaks 
                         .nodes    = block (new @lhs.label) @self : @cases.nodes
                         .edges    = @cases.edges
                         .breaks   = filter (not . isLabelOfThisLoop Nothing) @cases.breaks
                    cases.label    = new @lhs.label
                         .parent   = block (new @lhs.label) @self
                         .guard    = @exp.self
                         .previous = []

attr SwitchBlocks'
    inh parent   :: {CFGNode}
    inh guard    :: Exp'
    inh previous :: SwitchBlocks' --{[SwitchBlock']}
                    
sem SwitchBlocks'
    | Cons lhs.init     = @hd.init
              .edges    = -- Edges from expression to each case.
                          newCondEdge @lhs.parent @hd.init (caseCondExp @lhs.guard @lhs.previous @hd.self) 
                          : -- Edges from final of case to init of the next.
                          (if @tl.init == noInit
                               then [] else newIntraEdges @hd.final @tl.init)
                          -- Edges from the body and rest of the list. 
                          ++ @hd.edges ++ @tl.edges
           tl .previous = @hd.self : @lhs.previous 

    | Nil  lhs.final    = []
              .init     = noInit

sem SwitchBlock'
    | SwitchBlock' lhs.init  = @stat.init
                      .final = @stat.final

{
caseCondExp :: Exp' -> [SwitchBlock'] -> SwitchBlock' -> Exp'
caseCondExp e1 previous (SwitchBlock' Nothing _)   
    = let exps = [e | (SwitchBlock' (Just e) _) <- previous]
       in foldr (\ e -> BinOp' (BinOp' e1 NotEq' e) CAnd') (Lit' (Boolean' True)) exps
caseCondExp e1 _ (SwitchBlock' (Just e2) _) 
    = BinOp' e1 Equal' e2

noInit :: (Node, CFGNodeValue)
noInit = (-1, undefined)
}

sem Stmt'
    | Decl'     lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]
                    .edges = createInterEdges (new @lhs.label) @lhs.method @lhs.methods @vars.invocations

    | Empty'    lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]

    | ExpStmt'  lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]
                    .edges = createInterEdges (new @lhs.label) @lhs.method @lhs.methods @exp.invocations

    | Assert'   lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]
                    .edges = createInterEdges (new @lhs.label) @lhs.method @lhs.methods @exp.invocations
                             ++
                             createInterEdges (new @lhs.label) @lhs.method @lhs.methods (invocations @error)

    | Assume'   lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]
                    .edges = createInterEdges (new @lhs.label) @lhs.method @lhs.methods @exp.invocations

    | Break'    lhs .label  = new @lhs.label
                    .init   = block (new @lhs.label) (Stmt' @self)
                    .final  = []
                    .nodes  = [block (new @lhs.label) (Stmt' @self)]
                    .breaks = [block (new @lhs.label) (Stmt' @self)]

    | Continue' lhs .label     = new @lhs.label
                    .init      = block (new @lhs.label) (Stmt' @self)
                    .final     = []
                    .nodes     = [block (new @lhs.label) (Stmt' @self)]
                    .continues = [block (new @lhs.label) (Stmt' @self)]

    | Return'   lhs .label   = new @lhs.label
                    .init    = block (new @lhs.label) (Stmt' @self)
                    .final   = []
                    .nodes   = [block (new @lhs.label) (Stmt' @self)]
                    .edges   = createInterEdges (new @lhs.label) @lhs.method @lhs.methods (invocations @exp)
                    .returns = [block (new @lhs.label) (Stmt' @self)]

--------------------------------------------------------------------------------
-- Expressions
--------------------------------------------------------------------------------

attr Exps' Exp' MethodInvocation' VarDecls' VarDecl' VarInit'
    syn invocations use {++} {[]} :: {[Name']}
                
sem MethodInvocation'
    | MethodCall' lhs.invocations = [@name] ++ @args.invocations
                
{
invocations :: Maybe Exp' -> [Name']
invocations (Just e) = invocations_Syn_Exp' $ wrap_Exp' (sem_Exp' e) Inh_Exp'{}
invocations Nothing  = []
}

--------------------------------------------------------------------------------
-- Auxiliary functions
--------------------------------------------------------------------------------

{
type Methods = M.Map Name' (Node, Node)

new :: Node -> Node
new = (1+)

newIfJust :: Maybe a -> Node -> Node
newIfJust = maybe id (const new)

block :: Node -> CompoundStmt' -> CFGNode
block n s = (n, Block s)

entry :: Node -> Name' -> CFGNode
entry n name = (n, Entry name)

exit :: Node -> Name' -> CFGNode
exit n name =  (n, Exit name)

newIntraEdge :: CFGNode -> CFGNode -> CFGEdge
newIntraEdge (x,_) (y,_) = (x, y, IntraEdge)

newIntraEdges :: CFGNodes -> CFGNode -> CFGEdges
newIntraEdges xs y = map (`newIntraEdge` y) xs

createInterEdges :: Node -> Name' -> Methods -> [Name'] -> CFGEdges
createInterEdges label current methods invocations =
    newInterEdges label entries ++ map (\ (e,_) -> newInterEdge e (label, current)) exits
    where
        entries = map (\ i -> (fst (methods M.! i), i)) invocations
        exits   = map (\ i -> (snd (methods M.! i), i)) invocations

newCondEdge :: CFGNode -> CFGNode -> Exp' -> CFGEdge
newCondEdge (x,_) (y,_) e = (x, y, ConditionalEdge e)

newInterEdge :: Node -> (Node, Name') -> CFGEdge
newInterEdge x (y, n) = (x, y, InterEdge n)

newInterEdges :: Node -> [(Node, Name')] -> CFGEdges
newInterEdges x = map (newInterEdge x)

insertEdge :: CFGEdge -> CFG -> CFG
insertEdge edge graph = graph{cfg=insEdge edge (cfg graph)}

insertEdges :: [CFGEdge] -> CFG -> CFG
insertEdges edges graph = graph{cfg=insEdges edges (cfg graph)}

insertNode :: CFGNode -> CFG -> CFG
insertNode node graph = graph{cfg=insNode node (cfg graph)}
    
isLabelOfThisLoop :: Maybe String -> CFGNode -> Bool
isLabelOfThisLoop _        (_, Block (Stmt' (Break' Nothing)))      = True
isLabelOfThisLoop _        (_, Block (Stmt' (Continue' Nothing)))   = True
isLabelOfThisLoop Nothing  (_, Block (Stmt' (Break' (Just _))))     = False
isLabelOfThisLoop Nothing  (_, Block (Stmt' (Continue' (Just _))))  = False
isLabelOfThisLoop (Just l) (_, Block (Stmt' (Break' (Just l'))))    = l == l'
isLabelOfThisLoop (Just l) (_, Block (Stmt' (Continue' (Just l')))) = l == l'
isLabelOfThisLoop _        _                                        = error "Not a break or continue statement."

cfgOfCompilationUnit :: CompilationUnit' -> CFG
cfgOfCompilationUnit unit
    = cfg_Syn_CompilationUnit' $ wrap_CompilationUnit' (sem_CompilationUnit' unit) initial
    where
        initial = Inh_CompilationUnit' { label_Inh_CompilationUnit' = 0 }
}