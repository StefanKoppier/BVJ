{
data CFGNodeValue
    = NodeStmt      Stmt'
    | NodeVarDecl   BlockStmt'
    | NodeForInit   ForInit
    | NodeForUpdate [Exp]
    deriving (Show, Eq)
    
type CFGNode = LNode CFGNodeValue

instance {-# OVERLAPS #-} Ord CFGNode where
    (x,_) <= (y,_) = x <= y

type CFGNodes = S.Set CFGNode

type CFGEdge = UEdge

type CFGEdges = [CFGEdge]

type CFGContext = (Adj (), CFGNode, CFGNodeValue, Adj ())

type CFG = Gr CFGNodeValue ()
}

attr Block' BlockStmts' BlockStmt' Stmt'
    syn init                        :: {CFGNode}
    syn final                       :: {CFGNodes}
    syn breaks    use {<>} {mempty} :: {CFGNodes}
    syn continues use {<>} {mempty} :: {CFGNodes}
    chn cfg                         :: {CFG}
    chn label                       :: {Node}

sem Block'
    | Block' lhs.label = @blocks.label
                
sem BlockStmts'
    | Seq'  lhs  .label = @stat2.label
                 .init  = @stat1.init
                 .final = @stat2.final
                 .cfg   = @stat2.cfg
            stat1.label = @lhs.label
                 .cfg   = @lhs.cfg
            stat2.label = @stat1.label
                 .cfg   = case @stat1.self of
                            BlockStmt' (Break' _)
                                -> @stat1.cfg
                            BlockStmt' (Continue' _)
                                -> @stat1.cfg
                            _   -> insEdges (intraEdges @stat1.final @stat2.init) @stat1.cfg

    | Single' lhs.cfg = @s.cfg

sem BlockStmt'
    | LocalVars' lhs.label = new @lhs.label
                    .init  = nodeVarDecl (new @lhs.label) @self
                    .final = S.singleton $ nodeVarDecl (new @lhs.label) @self
                    .cfg   = insNode (nodeVarDecl (new @lhs.label) @self) @lhs.cfg

sem Stmt'
    | IfThen'       lhs .label = @stat.label
                        .init  = nodeStmt (new @lhs.label) @self
                        .final = S.insert (nodeStmt (new @lhs.label) @self) @stat.final
                        .cfg   = let self = nodeStmt (new @lhs.label) @self in
                                    -- Edge from condition to init of true branch.
                                    insEdge (intraEdge self @stat.init) $
                                    -- The node itself.
                                    insNode self @stat.cfg
                    stat.label = new @lhs.label
                        .cfg   = @lhs.cfg

    | IfThenElse'   lhs  .label = @stat2.label
                         .init  = nodeStmt (new @lhs.label) @self
                         .final = @stat1.final `S.union` @stat2.final
                         .cfg   = let self = nodeStmt (new @lhs.label) @self in
                                    -- Edge from condition to init of true branch.
                                    insEdge (intraEdge self @stat1.init) $
                                    -- Edge from condition to init of false branch.
                                    insEdge (intraEdge self @stat2.init) $
                                    -- The node itself.
                                    insNode self @stat2.cfg
                    stat1.label = new @lhs.label
                         .cfg   = @lhs.cfg
                    stat2.label = @stat1.label
                         .cfg   = @stat1.cfg
    
    | While'        lhs .label     = @body.label
                        .init      = nodeStmt (new @lhs.label) @self
                        .final     = S.insert (nodeStmt (new @lhs.label) @self) (S.filter (isLabelOfThisLoop @ident) @body.breaks)
                        .cfg       = let self = nodeStmt (new @lhs.label) @self in
                                        -- Edge from condition to the init of body.
                                        insEdge (intraEdge self @body.init)                                              $
                                        -- Edge(s) from finals of body to the condition.
                                        insEdges (intraEdges @body.final self)                                           $
                                        -- Edge(s) from continues of this loop to the condition.
                                        insEdges (intraEdges (S.filter (isLabelOfThisLoop @ident) @body.continues) self) $
                                        -- The node itself.
                                        insNode self @body.cfg
                        .breaks    = S.filter (not . isLabelOfThisLoop @ident) @body.breaks
                        .continues = S.filter (not . isLabelOfThisLoop @ident) @body.continues
                    body.label     = new @lhs.label
                        .cfg       = @lhs.cfg
    
    | BasicFor'    lhs  .label  = @body.label
                        .init   = maybe (nodeStmt (new @lhs.label) @self) (nodeForInit . new $ new @lhs.label) @init -- Init if it exists, otherwise the condition.
                        .final  = S.insert (nodeStmt (new @lhs.label) @self) (S.filter (isLabelOfThisLoop @ident) @body.breaks)
                        .cfg    = let self   = nodeStmt      (new @lhs.label) @self
                                      init   = nodeForInit   (new $ new @lhs.label)                   <$> @init
                                      update = nodeForUpdate (new $ new $ newIfJust @init @lhs.label) <$> @update in
                                        -- Edge from condition to init of body.
                                        insEdge (intraEdge self @body.init)                                                                $
                                        -- Edge(s) from body to update or condition, depending if update exists.
                                        insEdges (intraEdges @body.final (maybe self id update))                                           $
                                        -- Edge from initialisation to condition, if it exists.
                                        maybe id (\ init' -> insEdge $ intraEdge init' self) init                                          $
                                        -- Edge from update to condition, if it exists.
                                        maybe id (\ update' -> insEdge $ intraEdge update' self) update                                    $
                                        -- Edge(s) from continues of this loop to the update or condition, depending if update exists.
                                        insEdges (intraEdges (S.filter (isLabelOfThisLoop @ident) @body.continues) (maybe self id update)) $
                                        -- The condition node, if it exists.
                                        maybe id insNode init                                                                              $
                                        -- The update node, if it exists.
                                        maybe id insNode update                                                                            $
                                        -- The node itself.
                                        insNode self @body.cfg
                        .breaks    = S.filter (not . isLabelOfThisLoop @ident) @body.breaks
                        .continues = S.filter (not . isLabelOfThisLoop @ident) @body.continues
                    body.label     = new $ newIfJust @init $ newIfJust @update @lhs.label
                        .cfg       = @lhs.cfg

    | Empty'        lhs.label = new @lhs.label
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg

    | ExpStmt'      lhs.label = new @lhs.label
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg

    | Assert'       lhs.label = new @lhs.label
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       
    | Assume'       lhs.label = new @lhs.label
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg

    | Break'        lhs.label  = new @lhs.label
                       .init   = nodeStmt (new @lhs.label) @self
                       .final  = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg    = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .breaks = S.singleton $ nodeStmt (new @lhs.label) @self
        
    | Continue'     lhs.label     = new @lhs.label
                       .init      = nodeStmt (new @lhs.label) @self
                       .final     = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg       = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .continues = S.singleton $ nodeStmt (new @lhs.label) @self

    | Return'       lhs.label = new @lhs.label
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = S.singleton $ nodeStmt (new @lhs.label) @self
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg

{
new :: Node -> Node
new = (1+)

newIfJust :: Maybe a -> Node -> Node
newIfJust = maybe id (const new)

nodeStmt :: Node -> Stmt' -> CFGNode
nodeStmt l s = (l, NodeStmt s)

nodeVarDecl :: Node -> BlockStmt' -> CFGNode
nodeVarDecl l b = (l, NodeVarDecl b)

nodeForInit :: Node -> ForInit -> CFGNode
nodeForInit l i = (l, NodeForInit i)

nodeForUpdate :: Node -> [Exp] -> CFGNode
nodeForUpdate l u = (l, NodeForUpdate u)

intraEdge :: CFGNode -> CFGNode -> CFGEdge
intraEdge (x,_) (y,_) = (x, y, ())

intraEdges :: CFGNodes -> CFGNode -> CFGEdges
intraEdges xs y = S.toList $ S.map ((flip intraEdge) y) xs

isLabelOfThisLoop :: Maybe Ident -> CFGNode -> Bool
isLabelOfThisLoop _        (_, NodeStmt (Break' Nothing))      = True
isLabelOfThisLoop _        (_, NodeStmt (Continue' Nothing))   = True
isLabelOfThisLoop Nothing  (_, NodeStmt (Break' (Just _)))     = False
isLabelOfThisLoop Nothing  (_, NodeStmt (Continue' (Just _)))  = False
isLabelOfThisLoop (Just l) (_, NodeStmt (Break' (Just l')))    = l == l'
isLabelOfThisLoop (Just l) (_, NodeStmt (Continue' (Just l'))) = l == l'
isLabelOfThisLoop _        _                                   = error "Not a break or continue statement."

finalOfBlock :: Block' -> CFGNodes
finalOfBlock block
    = final_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0
                             , cfg_Inh_Block'   = empty }

initOfBlock :: Block' -> CFGNode
initOfBlock block
    = init_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0
                             , cfg_Inh_Block'   = empty }

cfgOfBlock :: Block' -> CFG
cfgOfBlock block
    = cfg_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0
                             , cfg_Inh_Block'   = empty }
}
