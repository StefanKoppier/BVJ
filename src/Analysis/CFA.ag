data Node
    | NodeStmt      label :: {Label}
                    value  :: Stmt'

    | NodeVarDecl   label :: {Label}
                    value :: BlockStmt'

    | NodeForInit   label :: {Label}
                    value :: {ForInit}

    | NodeForUpdate label :: {Label}
                    value :: {[Exp]}
deriving  Node : Eq

type Nodes = [Node]

attr Block' BlockStmts' BlockStmt' Stmt'
    syn nodes   use {++} {[]}       :: {Nodes}
    syn flow    use {<>} {mempty}   :: {Flow}
    syn init                        :: {Label}
    syn final                       :: {Labels}
    chn label                       :: {Label}

sem Block'
    | Block' lhs.label = @blocks.label

sem BlockStmts'
    | Seq'  lhs.label = maximum @s2.final
               .init  = @s1.init
               .final = @s2.final
               .flow  = @s1.flow                      <> 
                        @s2.flow                      <>
                        case @s1.self of 
                            BlockStmt' (Continue' _)
                                -> undefined
                            BlockStmt' (Break' _)
                                -> undefined
                            BlockStmt' (Return' _)
                                -> undefined
                            _   -> intraEdges @s1.final @s2.init 

sem BlockStmt'
    | LocalVars' lhs.label = new @lhs.label
                    .nodes = [NodeVarDecl (new @lhs.label) @self]
                    .init  = new @lhs.label
                    .final = [new @lhs.label]

sem Stmt'
    | StmtBlock'    lhs.label = maximum @block.final
                       .init  = @block.init
                       .final = @block.final
                       .flow  = @block.flow

    | IfThen'       lhs .label = maximum @stat.final
                        .nodes = (node (new @lhs.label) @self) : @stat.nodes
                        .init  = new @lhs.label
                        .final = @stat.final
                        .flow  = (intraEdge (new @lhs.label) @stat.init) <> @stat.flow
                    stat.label = new @lhs.label

    | IfThenElse'   lhs  .label = maximum @stat2.final
                         .nodes = (node (new @lhs.label) @self) : (@stat1.nodes ++ @stat2.nodes)
                         .init  = new @lhs.label
                         .final = @stat1.final ++ @stat2.final
                         .flow  = (intraEdge (new @lhs.label) @stat1.init) <> 
                                  (intraEdge (new @lhs.label) @stat2.init) <> 
                                  @stat1.flow                              <> 
                                  @stat2.flow
                    stat1.label = new @lhs.label
                    stat2.label = maximum @stat1.final

    | While'        lhs .label = maximum @body.final
                        .nodes = (node (new @lhs.label) @self) : @body.nodes
                        .init  = new @lhs.label
                        .final = [new @lhs.label]
                        .flow  = (intraEdge (new @lhs.label) @body.init)   <> 
                                 @body.flow                                <> 
                                 (intraEdges @body.final (new @lhs.label))
                    body.label = new @lhs.label

    | BasicFor'     lhs.label = maximum @body.final
                       .nodes = [node (new @lhs.label) @self]              ++ -- Condition node
                                (forInitNode (new $ new @lhs.label) @init) ++ -- Initialisation node
                                @body.nodes                                ++ -- body nodes
                                (forUpdateNode (new $ new $ newIfJust @init @lhs.label) @update) --update node
                       .init  = new $ newIfJust @init @lhs.label -- Initialisation if it exists, otherwise the condition
                       .final = [new @lhs.label] -- Condition
                       .flow  = maybe mempty (const $ intraEdge (new $ new @lhs.label) (new @lhs.label)) @init <> -- Initialisation -> Condition
                                intraEdge (new @lhs.label) @body.init <> -- Condition -> Body
                                intraEdges @body.final (maybe (new @lhs.label) (const $ new $ new $ newIfJust @init @lhs.label) @update) <> -- Body -> Update/Condition
                                maybe mempty (const $ intraEdge (new $ new $ newIfJust @init @lhs.label) (new @lhs.label)) @update <> -- Update -> Condition
                                @body.flow 
                    body.label = new $ newIfJust @init $ newIfJust @update @lhs.label

    | Empty'        lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | ExpStmt'      lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Assert'       lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Break'        lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]
        
    | Continue'     lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

    | Return'       lhs.label = new @lhs.label
                       .nodes = [node (new @lhs.label) @self]
                       .init  = new @lhs.label
                       .final = [new @lhs.label]

{
newest :: Labels -> Label
newest = new . maximum

new :: Label -> Label
new = (1+)

newIfJust :: Maybe a -> Label -> Label
newIfJust (Just _) = new
newIfJust Nothing  = id

node :: Label -> Stmt' -> Node
node l s = NodeStmt l s

forInitNode :: Label -> Maybe ForInit -> [Node]
forInitNode l (Just i) = [NodeForInit l i]
forInitNode _ Nothing  = []

forUpdateNode :: Label -> Maybe [Exp] -> [Node]
forUpdateNode l (Just es) = [NodeForUpdate l es]
forUpdateNode _ Nothing   = []

flowOfBlock :: Block' -> Flow
flowOfBlock block
    = flow_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0 } 
        
nodesOfBlock :: Block' -> Nodes
nodesOfBlock block
    = nodes_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0 } 

instance Show Node where
    show (NodeStmt l s)      = show l ++ ": " ++ show s
    show (NodeVarDecl l s)   = show l ++ ": " ++ show s
    show (NodeForInit l s)   = show l ++ ": " ++ show s
    show (NodeForUpdate l s) = show l ++ ": " ++ show s
}
