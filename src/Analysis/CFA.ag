{
data CFGNodeValue
    = NodeStmt      Stmt'
    | NodeVarDecl   BlockStmt'
    | NodeForInit   ForInit
    | NodeForUpdate [Exp]
    deriving (Show, Eq)
    
type CFGNode = LNode CFGNodeValue

type CFGNodes = [CFGNode]

type CFGEdge = UEdge

type CFGEdges = [CFGEdge]

type CFGContext = (Adj (), CFGNode, CFGNodeValue, Adj ())

type CFG = Gr CFGNodeValue ()
}

attr Block' BlockStmts' BlockStmt' Stmt'
    syn init                        :: {CFGNode}
    syn final                       :: {CFGNodes}
    chn cfg                         :: {CFG}
    chn label                       :: {Node}

sem Block'
    | Block' lhs.label = @blocks.label
                
sem BlockStmts'
    | Seq'  lhs  .label = @stat2.label
                 .init  = @stat1.init
                 .final = @stat2.final
                 .cfg   = @stat2.cfg
            stat1.label = @lhs.label
                 .cfg   = @lhs.cfg
            stat2.label = @stat1.label
                 .cfg   = insEdges (intraEdges @stat1.final @stat2.init) @stat1.cfg

    | Single' lhs.cfg = @s.cfg

sem BlockStmt'
    | LocalVars' lhs.label = new @lhs.label
                    .nodes = [nodeVarDecl (new @lhs.label) @self]
                    .init  = nodeVarDecl (new @lhs.label) @self
                    .final = [nodeVarDecl (new @lhs.label) @self]
                    .cfg   = insNode (nodeVarDecl (new @lhs.label) @self) @lhs.cfg

sem Stmt'
    | IfThen'       lhs .label = @stat.label
                        .init  = nodeStmt (new @lhs.label) @self
                        .final = nodeStmt (new @lhs.label) @self : @stat.final
                        .cfg   = let self = nodeStmt (new @lhs.label) @self in
                                    -- Edge from condition to init of true branch.
                                    insEdge (intraEdge self @stat.init) $
                                    -- The node itself.
                                    insNode self @stat.cfg
                    stat.label = new @lhs.label
                        .cfg   = @lhs.cfg

    | IfThenElse'   lhs  .label = @stat2.label
                         .init  = nodeStmt (new @lhs.label) @self
                         .final = @stat1.final ++ @stat2.final
                         .cfg   = let self = nodeStmt (new @lhs.label) @self in
                                    -- Edge from condition to init of true branch.
                                    insEdge (intraEdge self @stat1.init) $
                                    -- Edge from condition to init of false branch.
                                    insEdge (intraEdge self @stat2.init) $
                                    -- The node itself.
                                    insNode self @stat2.cfg
                    stat1.label = new @lhs.label
                         .cfg   = @lhs.cfg
                    stat2.label = @stat1.label
                         .cfg   = @stat1.cfg
    
    | While'        lhs .label = @body.label
                        .init  = nodeStmt (new @lhs.label) @self
                        .final = [nodeStmt (new @lhs.label) @self]
                        .cfg   = let self = nodeStmt (new @lhs.label) @self in
                                    -- Edge from condition to the init of body.
                                    insEdge (intraEdge self @body.init)    $
                                    -- Edge from finals of body to the condition.
                                    insEdges (intraEdges @body.final self) $
                                    -- The node itself.
                                    insNode self @body.cfg
                    body.label = new @lhs.label
                        .cfg   = @lhs.cfg
    
    | BasicFor'    lhs .label  = @body.label
                       .init   = maybe (nodeStmt (new @lhs.label) @self) (nodeForInit . new $ new @lhs.label) @init -- Init if it exists, otherwise the condition.
                       .final  = [nodeStmt (new @lhs.label) @self]
                       .cfg    = let self   = nodeStmt      (new @lhs.label) @self
                                     init   = nodeForInit   (new $ new @lhs.label)                   <$> @init
                                     update = nodeForUpdate (new $ new $ newIfJust @init @lhs.label) <$> @update in
                                    -- Edge from condition to init of body.
                                    insEdge (intraEdge self @body.init)                             $
                                    -- Edge from body to update or condition, depending if update exists.
                                    insEdges (intraEdges @body.final (maybe self id update))        $
                                    -- Edge from initialisation to condition, if it exists.
                                    maybe id (\ init' -> insEdge $ intraEdge init' self) init       $
                                    -- Edge from update to condition, if it exists.
                                    maybe id (\ update' -> insEdge $ intraEdge update' self) update $
                                    -- The condition node, if it exists.
                                    maybe id insNode init                                           $
                                    -- The update node, if it exists.
                                    maybe id insNode update                                         $
                                    -- The node itself.
                                    insNode self @body.cfg
                    body.label = new $ newIfJust @init $ newIfJust @update @lhs.label
                        .cfg   = @lhs.cfg

    | Empty'        lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]

    | ExpStmt'      lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]

    | Assert'       lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]
                       
    | Assume'       lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]

    | Break'        lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]
        
    | Continue'     lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]

    | Return'       lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]

    | Labeled'      lhs.label = new @lhs.label
                       .cfg   = insNode (nodeStmt (new @lhs.label) @self) @lhs.cfg
                       .init  = nodeStmt (new @lhs.label) @self
                       .final = [nodeStmt (new @lhs.label) @self]

{
new :: Node -> Node
new = (1+)

newIfJust :: Maybe a -> Node -> Node
newIfJust = maybe id (const new)

nodeStmt :: Node -> Stmt' -> CFGNode
nodeStmt l s = (l, NodeStmt s)

nodeVarDecl :: Node -> BlockStmt' -> CFGNode
nodeVarDecl l b = (l, NodeVarDecl b)

nodeForInit :: Node -> ForInit -> CFGNode
nodeForInit l i = (l, NodeForInit i)

nodeForUpdate :: Node -> [Exp] -> CFGNode
nodeForUpdate l u = (l, NodeForUpdate u)

intraEdge :: CFGNode -> CFGNode -> CFGEdge
intraEdge (x,_) (y,_) = (x, y, ())

intraEdges :: CFGNodes -> CFGNode -> CFGEdges
intraEdges xs y = map ((flip intraEdge) y) xs

finalOfBlock :: Block' -> CFGNodes
finalOfBlock block
    = final_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0
                             , cfg_Inh_Block'   = empty }

initOfBlock :: Block' -> CFGNode
initOfBlock block
    = init_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0
                             , cfg_Inh_Block'   = empty }

cfgOfBlock :: Block' -> CFG
cfgOfBlock block
    = cfg_Syn_Block' $ wrap_Block' (sem_Block' block) initial
    where
        initial = Inh_Block' { label_Inh_Block' = 0
                             , cfg_Inh_Block'   = empty }
}
