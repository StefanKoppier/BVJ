imports {
import qualified Data.Map                          as M
import           Analysis.CFG
import           Data.Graph.Inductive.Graph
import           Parsing.Syntax
import           Parsing.Utility

import Debug.Trace
}

include "../Parsing/Syntax.ag"

attr TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmts' 
     CompoundStmt' Stmt' SwitchBlocks' SwitchBlock' MaybeExp' Exps' Exp' 
     MethodInvocation' VarDecls' VarDecl' VarInits' VarInit' MaybeVarInits' 
     ArrayIndex' Lhs' FieldAccess'
    inh ast :: CompilationUnit'

sem CompilationUnit'
    | CompilationUnit' decls.ast = @self

attr CompilationUnit' TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' 
     CompoundStmts' CompoundStmt' Stmt'  SwitchBlocks' SwitchBlock'
    syn nodes use {++} {[]} :: {CFGNodes}
    syn edges use {++} {[]} :: {CFGEdges}
    chn label               :: {Node}

--------------------------------------------------------------------------------
-- Files
--------------------------------------------------------------------------------

attr CompilationUnit'
    syn cfg :: {CFG}

sem CompilationUnit'
    | CompilationUnit' lhs.cfg = constructCFG (unknownNode : @decls.nodes) @decls.edges

--------------------------------------------------------------------------------
-- Methods
--------------------------------------------------------------------------------

attr Decls' Decl' MemberDecl' CompoundStmts' CompoundStmt' Stmt' MaybeExp' Exps' 
     Exp' MethodInvocation' VarDecls' VarDecl' MaybeVarInits' VarInits' VarInit' 
     Lhs' ArrayIndex' FieldAccess' SwitchBlocks' SwitchBlock'
    inh className :: {String}

attr CompilationUnit' TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl'
    syn methods use {M.union} {M.empty} :: {Methods} 

sem ClassDecl'
    | ClassDecl' body.className = @name

sem MemberDecl'
    | MethodDecl'       lhs .label   = new @body.label
                            .methods = let scope = Scope Nothing @lhs.className @name
                                        in M.singleton scope (new @lhs.label, new @body.label)
                            .nodes   = let scope = Scope Nothing @lhs.className @name in
                                            -- Entry node of the method.
                                            entry (new @lhs.label) scope
                                            : -- Exit node of the method.
                                            exit (new @body.label) scope
                                            : -- Nodes of the body.
                                            @body.nodes
                            .edges   = let scope  = Scope Nothing @lhs.className @name
                                           entry' = entry (new @lhs.label) scope
                                           exit'  = exit (new @body.label) scope in
                                           -- Edge from entry of method to body.
                                           intraEdge entry' @body.init 0
                                           ++ -- Edge(s) from final of body to exit of method.
                                           intraEdges @body.final exit' 0
                                           ++ -- Edge(s) from returns to exit of method.
                                           intraEdges @body.returns exit' 0
                                           ++ -- Edges of the body.
                                           @body.edges
                        body.label   = new @lhs.label
                            .method  = [@name]

    | ConstructorDecl'  lhs .label   = new @body.label
                            .methods = let scope = Scope Nothing @lhs.className @name
                                        in M.singleton scope (new @lhs.label, new @body.label)
                            .nodes   = let scope = Scope Nothing @lhs.className @name in
                                            -- Entry node of the method.
                                            entry (new @lhs.label) scope
                                            : -- Exit node of the method.
                                            exit (new @body.label) scope
                                            : -- Nodes of the body.
                                            @body.nodes
                            .edges   = let scope  = Scope Nothing @lhs.className @name 
                                           entry' = entry (new @lhs.label) scope
                                           exit'  = exit (new @body.label) scope in
                                           -- Edge from entry of method to body.
                                           intraEdge entry' @body.init 0
                                           ++ -- Edge(s) from final of body to exit of method.
                                           intraEdges @body.final exit' 0
                                           ++ -- Edge(s) from returns to exit of method.
                                           intraEdges @body.returns exit' 0
                                           ++ -- Edges of the body.
                                           @body.edges
                        body.label   = new @lhs.label
                            .method  = [@name]

attr TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmts' 
     CompoundStmt' Stmt' SwitchBlocks' SwitchBlock' MaybeExp' Exps' Exp' 
     MethodInvocation' VarDecls' VarDecl' VarInits' VarInit' MaybeVarInits' 
     Lhs' ArrayIndex' FieldAccess'
    inh methods :: {Methods}

sem CompilationUnit'
    | CompilationUnit' decls.methods = @decls.methods

sem MemberDecl'
    | MethodDecl'      body.methods = let scope = Scope Nothing @lhs.className @name
                                       in M.insert scope (new @lhs.label, new @body.label) @lhs.methods
    
    | ConstructorDecl' body.methods = let scope = Scope Nothing @lhs.className @name
                                       in M.insert scope (new @lhs.label, new @body.label) @lhs.methods

--------------------------------------------------------------------------------
-- Statements
--------------------------------------------------------------------------------

attr CompoundStmts' CompoundStmt' Stmt' SwitchBlocks' SwitchBlock'
    inh method                  :: Name'
    syn init                    :: {CFGNode}
    syn final                   :: {CFGNodes}
    syn breaks    use {++} {[]} :: {CFGNodes}
    syn continues use {++} {[]} :: {CFGNodes}
    syn returns   use {++} {[]} :: {CFGNodes}

attr CompoundStmt'
    syn guard :: {CFGNode}

{
seqEdges :: CompoundStmts' -> CFGNodes -> CFGNode -> CFGEdges
seqEdges [] _ _ = []
seqEdges (stat:_) final init
    | init == noNode
        = []
    | Block' _ <- stat
        = intraEdges final init 1
    | otherwise
        = intraEdges final init 0
}

sem CompoundStmts'
    | Cons  lhs .label = @tl.label
                .init  = @hd.init
                .final = if @tl.final == [noNode]
                            then @hd.final
                            else @tl.final
                .edges = case @hd.self of
                            Stmt' (Break' _)
                                -> @hd.edges
                            Stmt' (Continue' _)
                                -> @hd.edges
                            Stmt' (Return' _)
                                -> @hd.edges
                            Block' _
                                -> @hd.edges ++ @tl.edges
                                   ++ intraEdges @hd.final @tl.init (-1)
                            IfThenElse' _ _ _
                                -> @hd.edges ++ @tl.edges 
                                   ++ intraEdges @hd.final @tl.init (-1)
                            While' _ e _
                                -> let conditional = @hd.guard
                                       normal      = filter (conditional /=) @hd.final in
                                       condEdge conditional @tl.init (PreNot' e) 0
                                       ++ -- TODO: (-1) (-n) as these are the breaks inside the scope.
                                       intraEdges normal @tl.init 0 
                                       ++
                                       @hd.edges ++ @tl.edges
                            _   
                                -> @hd.edges ++ @tl.edges 
                                   ++ seqEdges @tl.self @hd.final @tl.init
                .nodes = @hd.nodes ++ @tl.nodes
            hd  .label = @lhs.label
            tl  .label = @hd.label
    | Nil   lhs .init  = noNode
                .final = [noNode]

sem CompoundStmt'
{-    | Seq'          lhs  .label = @stat2.label
                         .init  = @stat1.init
                         .final = @stat2.final
                         .edges = case @stat1.self of
                                    While' _ e _
                                       -> let conditional = @stat1.guard
                                              normal      = filter (conditional /=) @stat1.final in
                                              condEdge conditional @stat2.init (PreNot' e) 0
                                              :
                                              intraEdges normal @stat2.init 0
                                              ++
                                              @stat1.edges ++ @stat2.edges
                                    Stmt' (Break' _)
                                       -> @stat1.edges
                                    Stmt' (Continue' _)
                                       -> @stat1.edges
                                    Stmt' (ReturnExp' _)
                                       -> @stat1.edges
                                    Stmt' Return'
                                       -> @stat1.edges
                                    (IfThenElse' _ _ _)
                                       -> @stat1.edges ++ @stat2.edges 
                                          ++ intraEdges @stat1.final @stat2.init (-1)
                                    (Block' _)
                                       -> @stat1.edges ++ @stat2.edges
                                          ++ intraEdges @stat1.final @stat2.init (-1)
                                    _  -> @stat1.edges ++ @stat2.edges 
                                          ++ seqEdges @stat2.self @stat1.final @stat2.init
                    stat1.label = @lhs.label
                    stat2.label = @stat1.label
-}
    | Block'        lhs  .label    = @stat.label
                    stat .label    = @lhs.label
      
    | IfThenElse'   lhs  .label    = @stat2.label
                         .init     = if noNode == @exp.init 
                                        then (block (new @exp.label) @self)
                                        else @exp.init
                         .final    = @stat1.final ++ @stat2.final
                         .nodes    = block (new @exp.label) @self 
                                     : @exp.nodes ++ @stat1.nodes ++ @stat2.nodes
                         .edges    = let self = block (new @exp.label) @self in
                                       -- Edge from condition to init of true branch.
                                       condEdge self @stat1.init @exp.self 1
                                       ++ -- Edge from condition to init of false branch.
                                       condEdge self @stat2.init (PreNot' @exp.self) 1
                                       ++ -- Edge(s) of the branches.
                                       @stat1.edges ++ @stat2.edges ++ @exp.edges
                    exp  .label    = @lhs.label
                         .statNode = new @exp.label
                    stat1.label    = new @exp.label
                    stat2.label    = @stat1.label

    | While'        lhs .label     = @body.label
                        .init      = if noNode == @exp.init 
                                        then (block (new @exp.label) @self)
                                        else @exp.init
                        .final     = block (new @exp.label) @self : filter (isLabelOfThisNode @ident) @body.breaks
                        .nodes     = block (new @exp.label) @self : @body.nodes ++ @exp.nodes
                        .edges     = let self = block (new @exp.label) @self
                                         init = if noNode == @exp.init
                                                    then self else @exp.init in
                                         -- Edge from condition to the init body.
                                         condEdge self @body.init (@exp.self) 1
                                         ++ -- Edge(s) from finals of body to the condition.
                                         intraEdges @body.final init (-1)
                                         ++ -- Edge(s) from continues of this loop to the condition.
                                         intraEdges (filter (isLabelOfThisNode @ident) @body.continues) init (-1)
                                         ++ -- Edge(s) of the body.
                                         @body.edges ++ @exp.edges
                        .breaks    = filter (not . isLabelOfThisNode @ident) @body.breaks
                        .continues = filter (not . isLabelOfThisNode @ident) @body.continues
                        .guard     = block (new @exp.label) @self
                    exp .label     = @lhs.label
                        .statNode  = new @exp.label
                    body.label     = new @exp.label

    | Switch'       lhs  .label    = @cases.label
                         .init     = if noNode == @exp.init 
                                        then (block (new @exp.label) @self)
                                        else @exp.init
                         .final    = @cases.final ++ filter (isLabelOfThisNode Nothing) @cases.breaks 
                         .nodes    = block (new @exp.label) @self : @exp.nodes ++ @cases.nodes
                         .edges    = @exp.edges ++ @cases.edges
                         .breaks   = filter (not . isLabelOfThisNode Nothing) @cases.breaks
                    exp  .label    = @lhs.label
                         .statNode = new @exp.label
                    cases.label    = new @exp.label
                         .parent   = block (new @exp.label) @self
                         .guard    = @exp.self
                         .previous = []

attr SwitchBlocks'
    inh parent   :: {CFGNode}
    inh guard    :: Exp'
    inh previous :: SwitchBlocks'
                    
sem SwitchBlocks'
    | Cons lhs.init     = @hd.init
              .edges    = -- Edges from expression to each case.
                          condEdge @lhs.parent @hd.init (caseCondExp @lhs.guard @lhs.previous @hd.self) 1 
                          ++ -- Edges from final of case to init of the next.
                          (if @tl.init == noNode
                               then [] else intraEdges @hd.final @tl.init 0)
                          -- Edges from the body and rest of the list. 
                          ++ @hd.edges ++ @tl.edges
           tl .previous = @hd.self : @lhs.previous 

    | Nil  lhs.final    = []
              .init     = noNode

sem SwitchBlock'
    | SwitchBlock' lhs.init  = @stat.init
                      .final = @stat.final

sem Stmt'
    | Decl'     lhs .label = new @vars.label
                    .init  = if noNode == @vars.init 
                                then (block (new @vars.label) (Stmt' @self))
                                else @vars.init
                    .final = [block (new @vars.label) (Stmt' @self)]
                    .nodes = block (new @vars.label) (Stmt' @self) : @vars.nodes
                    .edges = @vars.edges
                vars.label = @lhs.label
                vars.statNode = 1 + @lhs.label + @vars.numberOfCalls

    | Empty'    lhs .label = new @lhs.label
                    .init  = block (new @lhs.label) (Stmt' @self)
                    .final = [block (new @lhs.label) (Stmt' @self)]
                    .nodes = [block (new @lhs.label) (Stmt' @self)]

    | ExpStmt'  lhs .label = new @exp.label
                    .init  = if noNode == @exp.init 
                                then (block (new @exp.label) (Stmt' @self))
                                else @exp.init
                    .final = [block (new @exp.label) (Stmt' @self)]
                    .nodes = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges = @exp.edges
                exp .label = @lhs.label
                exp .statNode = 1 + @lhs.label + @exp.numberOfCalls

    | Assert'   lhs .label = new @exp.label
                    .init  = if noNode == @exp.init 
                                then (block (new @exp.label) (Stmt' @self))
                                else @exp.init
                    .final = [block (new @exp.label) (Stmt' @self)]
                    .nodes = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges = @exp.edges
                exp .label = @lhs.label
                exp .statNode = 1 + @lhs.label + @exp.numberOfCalls

    | Assume'   lhs .label = new @exp.label
                    .init  = if noNode == @exp.init 
                                then (block (new @exp.label) (Stmt' @self))
                                else @exp.init
                    .final = [block (new @exp.label) (Stmt' @self)]
                    .nodes = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges = @exp.edges
                exp .label = @lhs.label
                exp .statNode = 1 + @lhs.label + @exp.numberOfCalls

    | Break'    lhs .label  = new @lhs.label
                    .init   = block (new @lhs.label) (Stmt' @self)
                    .final  = []
                    .nodes  = [block (new @lhs.label) (Stmt' @self)]
                    .breaks = [block (new @lhs.label) (Stmt' @self)]

    | Continue' lhs .label     = new @lhs.label
                    .init      = block (new @lhs.label) (Stmt' @self)
                    .final     = []
                    .nodes     = [block (new @lhs.label) (Stmt' @self)]
                    .continues = [block (new @lhs.label) (Stmt' @self)]

    | Return'   lhs .label    = new @exp.label
                    .init     = if noNode == @exp.init
                                    then (block (new @exp.label) (Stmt' @self))
                                    else @exp.init
                    .final    = []
                    .nodes    = block (new @exp.label) (Stmt' @self) : @exp.nodes
                    .edges    = @exp.edges
                    .returns  = [block (new @exp.label) (Stmt' @self)]
                exp .label    = @lhs.label
                    .statNode = 1 + @lhs.label + @exp.numberOfCalls

{-    | Return'   lhs .label   = new @lhs.label
                    .init    = block (new @lhs.label) (Stmt' @self)
                    .final   = []
                    .nodes   = [block (new @lhs.label) (Stmt' @self)]
                    .returns = [block (new @lhs.label) (Stmt' @self)]
-}
--------------------------------------------------------------------------------
-- Expressions and variable declarations
--------------------------------------------------------------------------------

attr MaybeExp' Exps' Exp' FieldAccess' VarDecls' VarDecl' VarInits' VarInit' 
     MaybeVarInits' MethodInvocation' ArrayIndex' Lhs' 
    chn label                       :: {Node}
    syn init                        :: {CFGNode}
    syn final                       :: {CFGNodes}
    syn nodes         use {++} {[]} :: {CFGNodes}
    syn edges         use {++} {[]} :: {CFGEdges}
    syn numberOfCalls use {+} {0}   :: {Int}

sem MethodInvocation'
    | MethodCall'        lhs.numberOfCalls = 1 + @args.numberOfCalls
    | PrimaryMethodCall' lhs.numberOfCalls = 1 + @exp.numberOfCalls + @args.numberOfCalls

sem Exp'
    | InstanceCreation' lhs.numberOfCalls = 1 + @args.numberOfCalls

attr MaybeExp' Exps' Exp' VarDecls' VarDecl' VarInits' VarInit' MethodInvocation'
     MaybeVarInits' ArrayIndex' Lhs'
    inh statNode :: {Node}

sem Exps'
    | Cons      lhs.init  = if noNode == @hd.init
                                then @tl.init
                                else @hd.init
                   .final = if null @tl.final
                                then @hd.final
                                else @tl.final
    | Nil       lhs.init  = noNode
                   .final = [] 

sem MaybeExp'
    | Nothing           lhs .init  = noNode
                            .final = []

sem Exp'
    | Lit'              lhs .label  = @lhs.label
                            .init   = noNode
                            .final  = []
                        
    | This'             lhs .init   = noNode
                            .final  = []

    | InstanceCreation' lhs .label = new @args.label
                            .init  = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        if noNode == @args.init
                                            then call (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self)
                                            else @args.init 
                            .final = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        [call (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self)]
                            .nodes = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        call (new @args.label) scope @lhs.statNode (nameOfClassType @ty.self) : @args.nodes
                            .edges = let scope = getScopeOfCreation @lhs.ast Nothing @lhs.className @lhs.types @self in
                                        -- Inter edge from the call to the entry
                                        callEdge (new @args.label, scope) @lhs.methods
                                        : -- Inter edge from the exit to the next node
                                        returnEdge (scope, new (new @args.label))  @lhs.methods
                                        ++ @args.edges
                        args.label = @lhs.label

    | ExpName'          lhs .label  = @lhs.label
                            .init   = noNode
                            .final  = []

    | BinOp'            lhs .label   = @exp2.label
                            .init    = if noNode == @exp1.init
                                        then @exp2.init
                                        else @exp1.init
                            .final  = if null @exp2.final
                                        then @exp1.final
                                        else @exp2.final
                            .edges  = @exp1.edges ++ @exp2.edges
                        exp1.label = @lhs.label
                        exp2.label = @exp1.label

    | Cond'             lhs .label = @e2.label
                            .init  = if noNode == @guard.init
                                        then if noNode == @e1.init
                                                then @e2.init
                                                else @e1.init
                                        else @guard.init
                            .final = if null @e2.final
                                        then if null @e1.final
                                                then @guard.final
                                                else @e2.final
                                        else @e1.final
                        guard.label = @lhs.label
                        e1   .label = @guard.label
                        e2   .label = @e1.label

sem MethodInvocation'
    | MethodCall' lhs.label  = new @args.label
                     .init   = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    if noNode == @args.init
                                        then call (new @args.label) scope @lhs.statNode @name.self
                                        else @args.init
                     .final  = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    [call (new @args.label) scope @lhs.statNode @name.self]
                     .nodes  = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    call (new @args.label) scope @lhs.statNode @name.self : @args.nodes
                     .edges  = let scope = getScopeOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @name.self in
                                    -- Inter edge from the call to the entry
                                    callEdge (new @args.label, scope) @lhs.methods
                                    : -- Inter edge from the exit to the next node
                                    returnEdge (scope, new (new @args.label))  @lhs.methods
                                    -- The edges of the call arguments.
                                    ++ @args.edges
                  args.label = @lhs.label

    | PrimaryMethodCall' lhs .label = new @args.label
                             .init  = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            if noNode == @exp.init
                                                then if noNode == @args.init
                                                        then call (new @args.label) scope @lhs.statNode [@name]
                                                        else @args.init
                                                else @exp.init
                             .final = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            [call (new @args.label) scope @lhs.statNode [@name]]
                             .nodes = let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                          scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            call (new @args.label) scope @lhs.statNode [@name]
                                            : @exp.nodes ++ @args.nodes
                             .edges =  let className = getResultClassNameOfInvocation @lhs.ast Nothing @lhs.className @lhs.types @exp.self
                                           scope     = getScopeOfInvocation @lhs.ast Nothing className @lhs.types [@name] in
                                            -- Inter edge from the call to the entry
                                            callEdge (new @args.label, scope) @lhs.methods
                                            : -- Inter edge from the exit to the next node
                                            returnEdge (scope, new (new @args.label)) @lhs.methods
                                            -- The edges of the exp and call arguments.
                                            ++ @exp.edges ++ @args.edges
                         exp .label = @lhs.label
                         args.label = @exp.label 

sem VarDecls'
    | Cons      lhs.init  = if noNode == @hd.init then @tl.init else @hd.init
    | Nil       lhs.init  = noNode
                   .final = []

sem VarDecl'
    | VarDecl'  lhs.label = @init.label
                   .init  = @init.init
                   .final = @init.final

sem VarInits'
    | Cons      lhs.init  = if noNode == @hd.init then @tl.init else @hd.init
    | Nil       lhs.init  = noNode
                   .final = []

sem MaybeVarInits'
    | Nothing   lhs.init  = noNode
                   .final = []

sem Lhs'
    | Name'     lhs.init  = noNode
                   .final = []

--------------------------------------------------------------------------------
-- Type environment
--------------------------------------------------------------------------------

{
type TypeEnvironment = M.Map Scope Type'

generateTypesFromDecls :: Maybe Name' -> String -> Type' -> VarDecls' -> TypeEnvironment
generateTypesFromDecls package className ty
    = foldr (\ (VarDecl' (VarId' name) _) -> (M.singleton (Scope package className name) ty `M.union`)) M.empty 

generateTypesFromParams :: Maybe Name' -> String -> FormalParams' -> TypeEnvironment
generateTypesFromParams package className
    = foldr (\ (FormalParam' _ ty (VarId' name)) -> (M.singleton (Scope package className name) ty `M.union`)) M.empty

generateTypesFromStmt :: Maybe Name' -> String -> CompoundStmt' -> TypeEnvironment
generateTypesFromStmt package className (Stmt' (Decl' _ ty vars)) 
    = generateTypesFromDecls package className ty vars
generateTypesFromStmt _ _ _
     = M.empty

getScopeOfCreation :: CompilationUnit' -> Maybe Name' -> String -> TypeEnvironment -> Exp' -> Scope
getScopeOfCreation _ package _ _ (InstanceCreation' (ClassType' [name]) args)
    = Scope package name name

getResultClassNameOfInvocation :: CompilationUnit' -> Maybe Name' -> String -> TypeEnvironment -> Exp' -> String
getResultClassNameOfInvocation unit package className types (MethodInv' (MethodCall' name args))
    = let scope                       = getScopeOfInvocation unit package className types name
          (Just method)               = getMethod unit scope
          (Just (Just (RefType' ty))) = getReturnTypeOfMethod method
          [resultName]                = nameOfRefType ty
       in resultName

getResultClassNameOfInvocation unit package className types (MethodInv' (PrimaryMethodCall' e name args))
    = let innerclassName              = getResultClassNameOfInvocation unit package className types e
          innerScope                  = Scope Nothing innerclassName name
          (Just method)               = trace (show innerScope) (getMethod unit innerScope)
          (Just (Just (RefType' ty))) = getReturnTypeOfMethod method
          [resultName]                = nameOfRefType ty
       in resultName

getScopeOfInvocation :: CompilationUnit' -> Maybe Name' -> String -> TypeEnvironment -> Name' -> Scope
getScopeOfInvocation _ package className _ [name]
    = Scope package className name

getScopeOfInvocation ast package className types (name:names)
    | (Just _) <- findClass name ast 
        = getScopeOfInvocation ast package name types names
    | otherwise
        = case types M.!? Scope package className name of
            Just ty' ->
                getScopeOfInvocation ast package (getNameOfType ty') types names
            Nothing  -> 
                unknownScope

getNameOfType :: Type' -> String
getNameOfType (RefType' (ClassRefType' (ClassType' [name]))) = name
}

attr TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl'
    syn fieldTypes use {M.union} {M.empty} :: {TypeEnvironment}

sem MemberDecl'
    | FieldDecl' lhs.fieldTypes = generateTypesFromDecls Nothing @lhs.className @ty.self @var.self

attr TypeDecls' TypeDecl' ClassDecl' Decls' Decl' MemberDecl' CompoundStmts' 
     CompoundStmt' Stmt' SwitchBlocks' SwitchBlock' MaybeExp' Exps' Exp' 
     MethodInvocation' FieldAccess' VarInits' VarInit' MaybeVarInits' ArrayIndex' 
     VarDecls' VarDecl' Lhs'
    inh types :: {TypeEnvironment}

sem CompilationUnit'
    | CompilationUnit' decls.types = @decls.fieldTypes

sem MemberDecl'
    | MethodDecl'       body.types = @lhs.types `M.union` generateTypesFromParams Nothing @lhs.className @params.self
    | ConstructorDecl'  body.types = @lhs.types `M.union` generateTypesFromParams Nothing @lhs.className @params.self

sem CompoundStmts'
    | Cons  tl.types = @lhs.types `M.union` generateTypesFromStmt Nothing @lhs.className @hd.self

--------------------------------------------------------------------------------
-- Auxiliary functions
--------------------------------------------------------------------------------

{
type Methods = M.Map Scope (Node, Node)

caseCondExp :: Exp' -> [SwitchBlock'] -> SwitchBlock' -> Exp'
caseCondExp e1 previous (SwitchBlock' Nothing _)   
    = let exps = [e | (SwitchBlock' (Just e) _) <- previous]
       in foldr (\ e -> BinOp' (BinOp' e1 NotEq' e) CAnd') (Lit' (Boolean' True)) exps
caseCondExp e1 _ (SwitchBlock' (Just e2) _) 
    = BinOp' e1 Equal' e2

unknownScope :: Scope
unknownScope = Scope Nothing "UNKNOWN" "UNKNOWN"

unknownNode :: (Node, CFGNodeValue)
unknownNode = (-1, Entry unknownScope)

noNode :: (Node, CFGNodeValue)
noNode = (-2, undefined)

new :: Node -> Node
new = (1+)

newIfJust :: Maybe a -> Node -> Node
newIfJust = maybe id (const new)

call :: Node -> Scope -> Node -> Name' -> CFGNode
call n scope statNode name = (n, Call scope statNode name)

block :: Node -> CompoundStmt' -> CFGNode
block n s = (n, Block s)

entry :: Node -> Scope -> CFGNode
entry n scope = (n, Entry scope)

exit :: Node -> Scope -> CFGNode
exit n scope =  (n, Exit scope)

intraEdge :: CFGNode -> CFGNode -> Int -> CFGEdges
intraEdge (x,_) yNode@(y,_) s 
    | noNode == yNode = []
    | otherwise       = [(x, y, IntraEdge s)]

intraEdges :: CFGNodes -> CFGNode -> Int -> CFGEdges
intraEdges xs y s
    | noNode == y = []
    | otherwise   = concatMap (\ x -> intraEdge x y s) xs

callEdge :: (Node, Scope) -> Methods -> CFGEdge
callEdge (node, scope) methods
    | scope == unknownScope
        = (node, fst unknownNode, InterEdge unknownScope 0)
    | Just method' <- method
        = (node, fst method', InterEdge scope 0)
    | Nothing  <- method
        = (node, fst unknownNode, InterEdge unknownScope 0)
    where
        method = methods M.!? scope

returnEdge :: (Scope, Node) -> Methods -> CFGEdges
returnEdge (scope, node) methods
    | scope == unknownScope
        = []
    | Just method' <- method
        = [(snd method', node, InterEdge scope 0)]
    | Nothing      <- method
        = []
    where
        method = methods M.!? scope

condEdge :: CFGNode -> CFGNode -> Exp' -> Int -> CFGEdges
condEdge (x,_) yNode@(y,_) e s 
    | yNode == noNode = []
    | otherwise       = [(x, y, ConditionalEdge e s)]

isLabelOfThisNode :: Maybe String -> CFGNode -> Bool
isLabelOfThisNode _        (_, Block (Stmt' (Break' Nothing)))      = True
isLabelOfThisNode _        (_, Block (Stmt' (Continue' Nothing)))   = True
isLabelOfThisNode Nothing  (_, Block (Stmt' (Break' (Just _))))     = False
isLabelOfThisNode Nothing  (_, Block (Stmt' (Continue' (Just _))))  = False
isLabelOfThisNode (Just l) (_, Block (Stmt' (Break' (Just l'))))    = l == l'
isLabelOfThisNode (Just l) (_, Block (Stmt' (Continue' (Just l')))) = l == l'
isLabelOfThisNode _        _                                        = error "Not a break or continue statement."

cfgOfCompilationUnit :: CompilationUnit' -> CFG
cfgOfCompilationUnit unit
    = cfg_Syn_CompilationUnit' $ wrap_CompilationUnit' (sem_CompilationUnit' unit) initial
    where
        initial = Inh_CompilationUnit' { label_Inh_CompilationUnit' = 0 }
}