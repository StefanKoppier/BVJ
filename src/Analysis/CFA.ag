imports {
import qualified Data.Set                          as S
import           Analysis.CFG
import           Data.Graph.Inductive.Graph    
import           Parsing.Syntax
}

include "../Parsing/Syntax.ag"

--------------------------------------------------------------------------------
-- Statements
--------------------------------------------------------------------------------

attr CompoundStmt' Stmt'
    syn init                              :: {CFGNode}
    syn final                             :: {CFGNodes}
    syn breaks    use {S.union} {S.empty} :: {CFGNodes}
    syn continues use {S.union} {S.empty} :: {CFGNodes}
    chn cfg                               :: {CFG}
    chn label                             :: {Node}

sem CompoundStmt'
    | Seq'          lhs     .label = @stat2.label
                            .init  = @stat1.init
                            .final = @stat2.final
                            .cfg   = @stat2.cfg
                    stat1   .label = @lhs.label
                            .cfg   = @lhs.cfg
                    stat2   .label = @stat1.label
                            .cfg   = case @stat1.self of
                                        Stmt' (Break' _)
                                            -> @stat1.cfg
                                        Stmt' (Continue' _)
                                            -> @stat1.cfg
                                        While' _ _ _
                                            -> let conditional = @stat1.init
                                                   normal      = @stat1.final S.\\ S.singleton conditional in
                                                    -- Edge from condition to init of next.
                                                    insEdge (newCondEdge conditional @stat2.init False) $
                                                    -- Edge from break(s) to init of next.
                                                    insEdges (newEdges normal @stat2.init) @stat1.cfg
                                        _   -> insEdges (newEdges @stat1.final @stat2.init) @stat1.cfg
                    
    | IfThenElse'   lhs     .label = @stat2.label
                            .init  = node (new @lhs.label) @self
                            .final = @stat1.final `S.union` @stat2.final
                            .cfg   = let self = node (new @lhs.label) @self in
                                        -- Edge from condition to init of true branch.
                                        insEdge (newCondEdge self @stat1.init True)  $
                                        -- Edge from condition to init of false branch.
                                        insEdge (newCondEdge self @stat2.init False) $
                                        -- The node itself.
                                        insNode self @stat2.cfg
                    stat1   .label = new @lhs.label
                            .cfg   = @lhs.cfg
                    stat2   .label = @stat1.label
                            .cfg   = @stat1.cfg

    | While'        lhs     .label     = @body.label
                            .init      = node (new @lhs.label) @self
                            .final     = S.insert (node (new @lhs.label) @self) (S.filter (isLabelOfThisLoop @ident) @body.breaks)
                            .cfg       = let self = node (new @lhs.label) @self in
                                            -- Edge from condition to the init of body.
                                            insEdge (newCondEdge self @body.init True)                                              $
                                            -- Edge(s) from finals of body to the condition.
                                            insEdges (newEdges @body.final self)                                           $
                                            -- Edge(s) from continues of this loop to the condition.
                                            insEdges (newEdges (S.filter (isLabelOfThisLoop @ident) @body.continues) self) $
                                            -- The node itself.
                                            insNode self @body.cfg
                            .breaks    = S.filter (not . isLabelOfThisLoop @ident) @body.breaks
                            .continues = S.filter (not . isLabelOfThisLoop @ident) @body.continues
                    body    .label     = new @lhs.label
                            .cfg       = @lhs.cfg

sem Stmt'
    | Decl'     lhs .label = new @lhs.label
                    .init  = node (new @lhs.label) (Stmt' @self)
                    .final = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg   = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg

    | Empty'    lhs .label = new @lhs.label
                    .init  = node (new @lhs.label) (Stmt' @self)
                    .final = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg   = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg

    | ExpStmt'  lhs .label = new @lhs.label
                    .init  = node (new @lhs.label) (Stmt' @self)
                    .final = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg   = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg

    | Assert'   lhs .label = new @lhs.label
                    .init  = node (new @lhs.label) (Stmt' @self)
                    .final = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg   = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg

    | Assume'   lhs .label = new @lhs.label
                    .init  = node (new @lhs.label) (Stmt' @self)
                    .final = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg   = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg

    | Break'    lhs .label  = new @lhs.label
                    .init   = node (new @lhs.label) (Stmt' @self)
                    .final  = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg    = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg
                    .breaks = S.singleton $ node (new @lhs.label) (Stmt' @self)

    | Continue' lhs .label     = new @lhs.label
                    .init      = node (new @lhs.label) (Stmt' @self)
                    .final     = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg       = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg
                    .continues = S.singleton $ node (new @lhs.label) (Stmt' @self)

    | Return'   lhs .label = new @lhs.label
                    .init  = node (new @lhs.label) (Stmt' @self)
                    .final = S.singleton $ node (new @lhs.label) (Stmt' @self)
                    .cfg   = insNode (node (new @lhs.label) (Stmt' @self)) @lhs.cfg

--------------------------------------------------------------------------------
-- Expressions
--------------------------------------------------------------------------------

{-
attr Exp'
    invocations :: {[MethodInvocation']}
        
sem Exp'
    | MethodInv'    lhs.invocations = [@invocation.self]

    | BinOp'        lhs.invocations = @exp1.invocations ++ @exp2.invocations

    | Cond' 
-}

--------------------------------------------------------------------------------
-- Auxiliary functions
--------------------------------------------------------------------------------

{
new :: Node -> Node
new = (1+)

newIfJust :: Maybe a -> Node -> Node
newIfJust = maybe id (const new)

node :: Node -> CompoundStmt' -> CFGNode
node l s = (l, s)

newEdge :: CFGNode -> CFGNode -> CFGEdge
newEdge (x,_) (y,_) = (x, y, Edge)

newEdges :: CFGNodes -> CFGNode -> CFGEdges
newEdges xs y = S.toList $ S.map ((flip newEdge) y) xs

newCondEdge :: CFGNode -> CFGNode -> Bool -> CFGEdge
newCondEdge (x,_) (y,_) b = (x, y, ConditionalEdge b)

newCondEdges :: CFGNodes -> CFGNode -> Bool -> CFGEdges
newCondEdges xs y b = S.toList $ S.map (\ x -> newCondEdge x y b) xs

isLabelOfThisLoop :: Maybe String -> CFGNode -> Bool
isLabelOfThisLoop _        (_, Stmt' (Break' Nothing))      = True
isLabelOfThisLoop _        (_, Stmt' (Continue' Nothing))   = True
isLabelOfThisLoop Nothing  (_, Stmt' (Break' (Just _)))     = False
isLabelOfThisLoop Nothing  (_, Stmt' (Continue' (Just _)))  = False
isLabelOfThisLoop (Just l) (_, Stmt' (Break' (Just l')))    = l == l'
isLabelOfThisLoop (Just l) (_, Stmt' (Continue' (Just l'))) = l == l'
isLabelOfThisLoop _        _                                   = error "Not a break or continue statement."

finalOfStmt :: CompoundStmt' -> CFGNodes
finalOfStmt stat
    = final_Syn_CompoundStmt' $ wrap_CompoundStmt' (sem_CompoundStmt' stat) initial
    where
        initial = Inh_CompoundStmt' { label_Inh_CompoundStmt' = 0
                                    , cfg_Inh_CompoundStmt'   = empty }

initOfStmt :: CompoundStmt' -> CFGNode
initOfStmt stat
    = init_Syn_CompoundStmt' $ wrap_CompoundStmt' (sem_CompoundStmt' stat) initial
    where
        initial = Inh_CompoundStmt' { label_Inh_CompoundStmt' = 0
                                    , cfg_Inh_CompoundStmt'   = empty }

cfgOfStmt :: CompoundStmt' -> CFG
cfgOfStmt stat
    = cfg_Syn_CompoundStmt' $ wrap_CompoundStmt' (sem_CompoundStmt' stat) initial
    where
        initial = Inh_CompoundStmt' { label_Inh_CompoundStmt' = 0
                                    , cfg_Inh_CompoundStmt'   = empty }
}