imports {
import qualified Data.Set                     as S 
import           Language.C.Syntax.AST
import           Parsing.Syntax
import           Parsing.Utility

import Debug.Trace
}

include "../../Parsing/Syntax.ag"

--------------------------------------------------------------------------------
-- Gathering of all class and array types used and constructed.
--------------------------------------------------------------------------------

attr MemberDecl' ProgramPath' Stmt' ArrayIndex' MethodInvocation' VarDecls' VarDecl' 
     MaybeExp' Exps' Exp' MaybeVarInits' VarInits' VarInit' 
    syn constructedClassTypes use {S.union} {S.empty} :: {S.Set ClassType'}

sem Exp'
    | InstanceCreation' lhs.constructedClassTypes = S.insert (nameOfRenamedClassType @ty.self) @args.constructedClassTypes

attr MemberDecl' ProgramPath' RefType' MaybeType' Type' ClassType' Stmt' VarDecls' 
     VarDecl' MaybeVarInits' VarInit' MaybeExp' Exps' Exp' Lhs' MethodInvocation' 
     FieldAccess'
    syn usedClassTypes use {S.union} {S.empty} :: {S.Set ClassType'}
    syn usedArrayTypes use {S.union} {S.empty} :: {S.Set Type'}

sem RefType'
    | ArrayType' lhs.usedArrayTypes = S.insert @ty.self @ty.usedArrayTypes

sem ClassType'
    | ClassType' lhs.usedClassTypes = S.singleton (nameOfRenamedClassType @self)

{ -- TODO: very hacky, this needs to be fixed.
nameOfRenamedClassType :: ClassType' -> ClassType'
nameOfRenamedClassType (ClassType' [name])
    = ClassType' [takeWhile (\ c -> c /= '_') name]
}

{
typesInProgram :: CompilationUnit' -> ProgramPath' -> ([ClassType'], [ClassType'], [Type'])
typesInProgram unit@(CompilationUnit' _ decls) path
    = let wrappedPath           = wrap_ProgramPath' (sem_ProgramPath' path) initialPath
          wrappedFields         = map (\ d -> wrap_MemberDecl' (sem_MemberDecl' d) initialDecl) fields
          constructedClasses    = constructedClassTypes_Syn_ProgramPath' wrappedPath
                                  : map constructedClassTypes_Syn_MemberDecl' wrappedFields
          usedClasses           = usedClassTypes_Syn_ProgramPath' wrappedPath 
                                  : map usedClassTypes_Syn_MemberDecl' wrappedFields
          usedArrayTypes        = usedArrayTypes_Syn_ProgramPath' wrappedPath
                                  : map usedArrayTypes_Syn_MemberDecl' wrappedFields
       in ( S.toList . S.unions $ constructedClasses
          , S.toList . S.unions $ usedClasses
          , S.toList . S.unions $ usedArrayTypes )
    where
        fields      = (concatMap getFields . getClasses) decls
        initialPath = Inh_ProgramPath'{}
        initialDecl = Inh_MemberDecl'{}
}